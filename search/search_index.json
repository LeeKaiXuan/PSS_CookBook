{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portable Test and Stimulus Standard (PSS) Cookbook","text":"<p>In this document, we summarize the LRM of PSS, and give you extra examples and tips. Besides that, AndesTech has build a simple DSL generator called PSSGen, which is open-source and free to use. So most of the examples in this document are tested in PSSGen.</p>"},{"location":"#symbol","title":"Symbols","text":""},{"location":"#vxy-lrm-minimum-version-vxy","title":"vx.y - LRM: Minimum version vx.y","text":"<p>There are multiple revision of PSS, but we only cover version 2.0 (denoted as PSSv2.0) and later. For some features are supported after PSSv2.0, we will mark it by this icon with the version number.</p>"},{"location":"#vxyz-pssgen-minimum-version-vxyz","title":"vx.y.z - PSSGen: Minimum version vx.y.z","text":"<p>For feature is supported by PSSGen, we will mark it by this icon with the version number.</p>"},{"location":"#not-support-yet-pssgen-not-supported-yet","title":"Not support yet - PSSGen: Not supported yet","text":"<p>For feature is NOT supported yet in PSSGen, we will mark it by this icon.</p>"},{"location":"#reference","title":"Reference","text":"<ul> <li>LRM: PSS 2.0 Language Reference Manual</li> <li>LRM: PSS 2.1 Language Reference Manual</li> <li>AndesTech PSS Generator: PSSGen</li> </ul>"},{"location":"Collections/Arrays/","title":"Array","text":"<p>v1.0.0</p>"},{"location":"Collections/Arrays/#properties","title":"Properties","text":"<ul> <li>Ordered by index.</li> <li>Randomizable when its data_type is randomizable (e.g., randomizable scalar or aggregate of randomizable scalar).</li> <li>Element and data_type can be any scalar or aggregate of scalar.</li> <li>Index must be non-negative integer.</li> <li>Size must be non-zero integer.</li> <li>Can be nested by any collection types (e.g., <code>array</code>, <code>list</code>, <code>map</code> or <code>set</code>).</li> </ul>"},{"location":"Collections/Arrays/#declarations","title":"Declarations","text":"<p>v2.2.0</p> <p>Not support yet</p> <p>PSSGen: Not support <code>float32</code>, <code>float64</code>, and <code>chandle</code> as data_type.</p> <p>Array has 2 declaration formats:</p> Format Syntax <code>Template</code> array&lt;data_type, size&gt; identifier <code>Square</code> data_type identifier [size] TemplateSquare <pre><code>array&lt;int    , 3&gt; intArray   ;          //  intArray   : {   0,    0,    0}\narray&lt;bit [8], 3&gt; byteArray  ;          //  byteArray  : {8'b0, 8'b0, 8'b0}\narray&lt;string , 3&gt; stringArray;          //  stringArray: {  \"\",   \"\",   \"\"}\narray&lt;array&lt;int, 3&gt;, 2&gt; nestedArray;    //  nestedArray: {{0, 0, 0}, {0, 0, 0}}\n</code></pre> <pre><code>int     intArray    [3];                //  intArray   : {   0,    0,    0}\nbit [8] byteArray   [3];                //  byteArray  : {8'b0, 8'b0, 8'b0}\nstring  stringArray [3];                //  stringArray: {  \"\",   \"\",   \"\"}\n// (1)!\n</code></pre> <ol> <li><code>square</code> format NOT support for declare nested array</li> </ol> Note <p>Array is a fixed-size collection, which's size must be assigned by a non-zero integer, and cannot be changed after declared.</p>"},{"location":"Collections/Arrays/#declare-array-by-rand-keyword","title":"Declare array by <code>rand</code> keyword","text":"<p>v2.2.0</p> TemplateSquare <pre><code>rand array&lt;int, 3&gt; intArray;    //  declare integer array with 3 random elements\n</code></pre> <pre><code>rand int intArray [3];          //  declare integer array with 3 random elements\n</code></pre>"},{"location":"Collections/Arrays/#initialization-assignment","title":"Initialization Assignment","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element in initialization assignment.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element in initialization assignment.</p> <p>Array can be assigned at declaration; otherwise, each elements will be initialized to default initial value.</p> TemplateSquare <pre><code>array&lt;int    , 2&gt; intArray    = {    1,     2};         //  intArray   : {    1,     2}\narray&lt;bit [8], 2&gt; byteArray   = {8'b01, 8'b10};         //  byteArray  : {8'b01, 8'b10}\narray&lt;string , 2&gt; stringArray = {  \"A\",   \"B\"};         //  stringArray: {  \"A\",   \"B\"}\narray&lt;array&lt;int, 2&gt;, 2&gt; nestedArray = {{1, 2}, {3, 4}}; //  nestedArray: {{1, 2}, {3, 4}}\n</code></pre> <pre><code>int     intArray    [2] = {    1,     2};               //  intArray   : {    1,     2}\nbit [8] byteArray   [2] = {8'b01, 8'b10};               //  byteArray  : {8'b01, 8'b10}\nstring  stringArray [2] = {  \"A\",   \"B\"};               //  stringArray: {  \"A\",   \"B\"}\n// (1)!\n</code></pre> <ol> <li><code>square</code> format NOT support for declare nested array</li> </ol>"},{"location":"Collections/Arrays/#array-operators","title":"Array Operators","text":"Operator Description <code>[]</code> Used to access a specific element of an array by given index, which must be a non-negative integer. <code>=</code> Creates a copy of the <code>array</code>-type expression on the RHS and assigns it to the array on the LHS. <code>==</code> Evaluates to true if both sizes are equal and all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true whether both sizes are not equal or if any element with corresponding index is not equal. <code>in</code> Evaluates to true if element on LHS of <code>in</code> is exists in the array. <code>foreach</code> Iterates over the array's elements."},{"location":"Collections/Arrays/#array-methods","title":"Array Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the array. int <code>sum()</code> Returns the sum of all elements in the array, when data_type of element is <code>bit</code> or <code>int</code>. float64 <code>sum()</code>Not support yet v2.1 Returns the sum of all elements in the array, when data_type of element is <code>float32</code> or <code>float64</code>. list&lt;data_type&gt; <code>to_list()</code> Returns all elements to a <code>list</code>-type. set&lt;data_type&gt; <code>to_set()</code>: Returns all elements to a <code>set</code>-type."},{"location":"Collections/Arrays/#index","title":"Index operator <code>[]</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element for index operator <code>[]</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element for index operator <code>[]</code>.</p> <p>Used to access a specific element of an array by given index, which must be a non-negative integer.</p> TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nint intVal = intArray[2];   //  intVal: 0 -&gt; 3\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nint intVal = intArray[2];   //  intVal: 0 -&gt; 3\n</code></pre>"},{"location":"Collections/Arrays/#assignment","title":"Assignment operator <code>=</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element for assignment operator <code>=</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element for assignment operator <code>=</code>.</p> <p>Creates a copy of the <code>array</code>-type expression on the RHS and assigns it to the array on the LHS.</p> TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nintArray = {3, 4, 5};       //  intArray: {1, 2, 3} -&gt; {3, 4, 5}\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nintArray = {3, 4, 5};       //  intArray: {1, 2, 3} -&gt; {3, 4, 5}\n</code></pre> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Arrays/#equality","title":"Equality operator <code>==</code>","text":"<p>v2.2.0</p> <p>Evaluates to true if both sizes are equal and all elements with corresponding indexes are equal.</p> TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0  = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1  = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 == intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0 == intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0 == stringArray) bitVal_2 = 1;    //  ILLEGAL (3)\n</code></pre> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type between arrays are incomparable.</li> </ol> <pre><code>int    intArray_0  [2] = {  1 ,  2      };\nint    intArray_1  [3] = {  1 ,  2 ,  3 };\nstring stringArray [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 == intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0 == intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0 == stringArray) bitVal_2 = 1;    //  ILLEGAL (3)\n</code></pre> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type between arrays are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of element of two arrays should NOT be compared.</p>"},{"location":"Collections/Arrays/#inequality","title":"Inequality operator <code>!=</code>","text":"<p>v2.2.0</p> <p>Evaluates to true whether both sizes are not equal or if any element with corresponding index is not equal.</p> TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0  = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1  = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 != intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0 != intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 1 (2)\nif (intArray_0 != stringArray) bitVal_2 = 1;    //  ILLEGAL (3)\n</code></pre> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type between arrays are incomparable.</li> </ol> <pre><code>int    intArray_0  [2] = {  1 ,  2      };\nint    intArray_1  [3] = {  1 ,  2 ,  3 };\nstring stringArray [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 != intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0 != intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 1 (2)\nif (intArray_0 != stringArray) bitVal_2 = 1;    //  ILLEGAL (3)\n</code></pre> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type between arrays are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of element of two arrays should NOT be compared.</p>"},{"location":"Collections/Arrays/#in","title":"Set membership operator <code>in</code>","text":"<p>v2.2.0</p> <p>Evaluates to true if element on LHS of <code>in</code> is exists in the array.</p> TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif ( 1  in intArray) bitVal_0 = 1;              //  bitval_0: 0 -&gt; 1\nif ( 0  in intArray) bitVal_1 = 1;              //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intArray) bitVal_2 = 1;              //  ILLEGAL (1)\n</code></pre> <ol> <li>Different data_type between LHS of <code>in</code> and the array's element on RHS of <code>in</code>.</li> </ol> <pre><code>int intArray [3] = {1, 2, 3};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif ( 1  in intArray) bitVal_0 = 1;              //  bitval_0: 0 -&gt; 1\nif ( 0  in intArray) bitVal_1 = 1;              //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intArray) bitVal_2 = 1;              //  ILLEGAL (1)\n</code></pre> <ol> <li>Different data_type between LHS of <code>in</code> and the array's element on RHS of <code>in</code>.</li> </ol> <p>Warning</p> <p>Data_type of element on LHS of <code>in</code> should be SAME as the array's element on RHS of <code>in</code>.</p>"},{"location":"Collections/Arrays/#foreach","title":"<code>foreach</code> statement","text":"<p>v2.2.0</p> <p>Iterates over the array's elements.</p> <p>Look at Procedural/<code>foreach</code> for more information.</p> TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {4, 5, 6};\nint intVal_0 = 0;\nint intVal_1 = 0;\nint intVal_2 = 0;\n\nforeach (i : intArray[j]) {\n    intVal_0 = i;               //  intVal_0: 0 -&gt; 4 -&gt; 5 -&gt; 6\n    intVal_1 = j;               //  intVal_1: 0 -&gt; 0 -&gt; 1 -&gt; 2\n    intVal_2 = intArray[j];     //  intVal_2: 0 -&gt; 4 -&gt; 5 -&gt; 6\n}\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\nint intVal_0 = 0;\nint intVal_1 = 0;\nint intVal_2 = 0;\n\nforeach (i : intArray[j]) {\n    intVal_0 = i;               //  intVal_0: 0 -&gt; 4 -&gt; 5 -&gt; 6\n    intVal_1 = j;               //  intVal_1: 0 -&gt; 0 -&gt; 1 -&gt; 2\n    intVal_2 = intArray[j];     //  intVal_2: 0 -&gt; 4 -&gt; 5 -&gt; 6\n}\n</code></pre>"},{"location":"Collections/Arrays/#size","title":"function int <code>size()</code>","text":"<p>v2.2.0</p> <p>Returns the number of elements in the array.</p> TemplateSquare <pre><code>array&lt;int, 2&gt; intArray;\n\nint intVal = intArray.size();       //  intVal: 0 -&gt; 2\n</code></pre> <pre><code>int intArray [2];\n\nint intVal = intArray.size();       //  intVal: 0 -&gt; 2\n</code></pre> Note <p>Considered as a constant expression.</p>"},{"location":"Collections/Arrays/#sum_int","title":"function int <code>sum()</code>","text":"<p>v2.2.0</p> <p>Returns the sum of all elements in the array, when data_type of element is <code>bit</code> or <code>int</code>.</p> TemplateSquare <pre><code>array&lt;int    , 2&gt; intArray    = {  1   ,  2    };\narray&lt;bit [2], 2&gt; bitArray    = { 2'b01, 2'b10 };\narray&lt;string , 2&gt; stringArray = { \"1\"  , \"2\"   };\n\nint intVal_0 = intArray.sum()   ;   //  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;   //  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();   //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <pre><code>int     intArray    [2] = {  1   ,  2    };\nbit [2] bitArray    [2] = { 2'b01, 2'b10 };\nstring  stringArray [2] = { \"1\"  , \"2\"   };\n\nint intVal_0 = intArray.sum()   ;   //  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;   //  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();   //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <p>Warning</p> <p>The <code>data-type</code> of <code>element</code> should be integer types (e.g., <code>int</code> or <code>bit</code>).</p> Usage: use <code>sum()</code> to constrain a random array TemplateSquare <pre><code>rand array&lt;int, 2&gt; intArray;\n\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;   //  intArray: {0, 0} -&gt; {2, 1}\n}\n</code></pre> <pre><code>rand int intArray [2];\n\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;   //  intArray: {0, 0} -&gt; {2, 1}\n}\n</code></pre>"},{"location":"Collections/Arrays/#sum_float","title":"function float64 <code>sum()</code>","text":"<p>Not support yet v2.1</p> <p>Returns the sum of all elements in the array, when data_type of element is <code>float32</code> or <code>float64</code>.</p> TemplateSquare <pre><code>array&lt;float32, 2&gt; float32Array = {1.0, 2.0};\narray&lt;flaot64, 2&gt; float64Array = {1.0, 2.0};\narray&lt;string , 2&gt; stringArray  = {\"1\", \"2\"};\n\nflaot64 fVal_0 = intArray.sum()   ; //  fVal_0: 0.0 -&gt; 3.0\nflaot64 fVal_1 = bitArray.sum()   ; //  fVal_1: 0.0 -&gt; 3.0\nflaot64 fVal_2 = stringArray.sum(); //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <pre><code>float32 float32Array [2] = {1.0, 2.0};\nflaot64 float64Array [2] = {1.0, 2.0};\nstring  stringArray  [2] = {\"1\", \"2\"};\n\nflaot64 fVal_0 = intArray.sum()   ; //  fVal_0: 0.0 -&gt; 3.0\nflaot64 fVal_1 = bitArray.sum()   ; //  fVal_1: 0.0 -&gt; 3.0\nflaot64 fVal_2 = stringArray.sum(); //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <p>Warning</p> <p>The <code>data-type</code> of <code>element</code> should be floating-point types (e.g., <code>float32</code> or <code>float64</code>).</p>"},{"location":"Collections/Arrays/#to_list","title":"function list&lt;data_type&gt; <code>to_list()</code>","text":"<p>v2.2.0</p> <p>Returns all elements to a <code>list</code>-type.</p> TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\n\nlist&lt;int   &gt; intList    = intArray.to_list()   ;    //  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();    //  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\n\nlist&lt;int   &gt; intList    = intArray.to_list()   ;    //  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();    //  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre>"},{"location":"Collections/Arrays/#to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>","text":"<p>v2.2.0</p> <p>Returns all elements to a <code>set</code>-type.</p> TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\n\nset&lt;int   &gt; intSet    = intArray.to_set()   ;       //  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();       //  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\n\nset&lt;int   &gt; intSet    = intArray.to_set()   ;       //  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();       //  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre>"},{"location":"Collections/Lists/","title":"List","text":"<p>v2.2.0</p>"},{"location":"Collections/Lists/#properties","title":"Properties","text":"<ul> <li>Ordered by index.</li> <li>Randomizable when its data_type is randomizable (e.g., randomizable scalar or aggregate of randomizable scalar).</li> <li>Element and data_type can be any scalar or aggregate of scalar.</li> <li>Index must be non-negative integer.</li> <li>Can be nested by any collection types (e.g., <code>array</code>, <code>list</code>, <code>map</code> or <code>set</code>).</li> </ul>"},{"location":"Collections/Lists/#declarations","title":"Declarations","text":"<p>v2.2.0</p> <p>Not support yet</p> <p>PSSGen: Not support <code>chandle</code> as data_type.</p> <p>List can be declared by following syntax:</p> <p>list&lt;data_type&gt; identifier</p> <pre><code>list&lt;int     &gt; intList   ;  //  intList   : {}\nlist&lt;bit [8] &gt; byteList  ;  //  byteList  : {}\nlist&lt;bool    &gt; boolList  ;  //  boolList  : {}\nlist&lt;string  &gt; stringList;  //  stringList: {}\nlist&lt;eSTR2NUM&gt; enumList  ;  //  enumList  : {} (1)\nlist&lt;sSTR2NUM&gt; structList;  //  structList: {} (2)\n</code></pre> <ol> <li> <p>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></p> </li> <li> <p>Assume defined struct type before <pre><code>struct sSTR2NUM {\n    string stringVal;\n    int intVal;\n};\n</code></pre></p> </li> </ol>"},{"location":"Collections/Lists/#declare-list-by-rand-keyword","title":"Declare list by <code>rand</code> keyword","text":"<p>Not support yet v2.1</p> <pre><code>rand list&lt;int    &gt; intList   ;\nrand list&lt;bit [8]&gt; byteList  ;\nrand list&lt;string &gt; stringList;\n</code></pre>"},{"location":"Collections/Lists/#initialization-assignment","title":"Initialization Assignment","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element in initialization assignment.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element in initialization assignment.</p> <p>List can be assigned at declaration; otherwise, it will be initialized to empty aggregate literal (<code>{}</code>). <pre><code>list&lt;int    &gt; intList    = {1    , 2    };  //  intList   : {1    , 2    }\nlist&lt;bit [8]&gt; byteList   = {8'b01, 8'b10};  //  byteList  : {8'b01, 8'b10}\nlist&lt;bool   &gt; boolList   = {false, true };  //  boolList  : {false, true }\nlist&lt;string &gt; stringList = {\"1\"  , \"2\"  };  //  stringList: {\"1\"  , \"2\"  }\n</code></pre></p>"},{"location":"Collections/Lists/#list-operators","title":"List Operators","text":"Operator Description <code>[]</code> Used to access a specific element of a list by given index, which must be a non-negative integer. <code>=</code> Create a copy of the <code>list</code>-type expression on the RHS and assigns it to the list on the LHS. <code>==</code> Evaluates to true if both sizes are equal and all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true whether both sizes are not equal or if any element with corresponding index is not equal. <code>in</code> Evaluates to true if element on the LHS of <code>in</code> is exists in the list. <code>foreach</code> Iterates over the list's elements."},{"location":"Collections/Lists/#list-methods","title":"List Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the list. <code>clear()</code> Removes all elements from the list. &lt;data_type&gt; <code>delete(int index)</code> Moves out the element at the specified index, which must be a non-negative integer. <code>insert(int index, data_type element)</code> Adds the element to the specified index, and all elements at and beyond the index are moved by one. &lt;data_type&gt; <code>pop_front()</code> Moves out the first element from the list. Same as <code>delete(0)</code>. <code>push_front(data_type element)</code> Adds the element to the beginning of the list. Same as <code>insert(0, element)</code>. &lt;data_type&gt; <code>pop_back()</code> Moves out the last element from the list. Same as <code>delete(size()-1)</code>. <code>push_back(data_type element)</code> Adds the element to the end of the list. Same as <code>insert(size()-1, element)</code>. set&lt;data_type&gt; <code>to_set()</code> Returns all elements to a <code>set</code>-type. <code>shuffle()</code>v2.3.0 v2.1 Randomizes orders of elements."},{"location":"Collections/Lists/#index","title":"Index operator <code>[]</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element for index operator <code>[]</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element for index operator <code>[]</code>.</p> <p>Used to access a specific element of a list by given index, which must be a non-negative integer. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList[1];    //  intVal: 0 -&gt; 2\nint intVal = intList[9];    //  ILLEGAL (1)\n</code></pre></p> <ol> <li>The index is out of bounds.</li> </ol> <p>Warning</p> <p>Index should smaller than <code>size()</code> of the list.</p>"},{"location":"Collections/Lists/#assignment","title":"Assignment operator <code>=</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element for assignment operator <code>=</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element for assignment operator <code>=</code>.</p> <p>Create a copy of the <code>list</code>-type expression on the RHS and assigns it to the list on the LHS. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList = {2, 3, 4};        //  intList: {1, 2, 3} -&gt; {2, 3, 4}\n</code></pre></p> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#equality","title":"Equality operator <code>==</code>","text":"<p>v2.2.0</p> <p>Evaluates to true if both sizes are equal and all elements with corresponding indexes are equal. <pre><code>list&lt;int   &gt; intList_0  = { 1 ,  2 ,  3      };\nlist&lt;int   &gt; intList_1  = { 1 ,  2 ,  3 ,  4 };\nlist&lt;string&gt; stringList = {\"1\", \"2\", \"3\"};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intList_0 == intList_0 ) bitVal_0 = 1;  //  bitVal_0: 0 -&gt; 1; (1)\nif (intList_0 == intList_1 ) bitVal_1 = 1;  //  bitVal_1: 0 -&gt; 0; (2)\nif (intList_0 == stringList) bitVal_2 = 1;  //  ILLEGAL (3)\n</code></pre></p> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of two lists should NOT be compared.</p>"},{"location":"Collections/Lists/#inequality","title":"Inequality operator <code>!=</code>","text":"<p>v2.2.0</p> <p>Evaluates to true whether both sizes are not equal or if any element with corresponding index is not equal. <pre><code>list&lt;int   &gt; intList_0  = { 1 ,  2 ,  3      };\nlist&lt;int   &gt; intList_1  = { 1 ,  2 ,  3 ,  4 };\nlist&lt;string&gt; stringList = {\"1\", \"2\", \"3\"};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intList_0 != intList_0 ) bitVal_0 = 1;  //  bitVal_0: 0 -&gt; 0 (1)\nif (intList_0 != intList_1 ) bitVal_1 = 1;  //  bitVal_1: 0 -&gt; 1 (2)\nif (intList_0 != stringList) bitVal_2 = 1;  //  ILLEGAL (3)\n</code></pre></p> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of two lists should NOT be compared.</p>"},{"location":"Collections/Lists/#in","title":"Set membership operator <code>in</code>","text":"<p>v2.2.0</p> <p>Evaluates to true if element on the LHS of <code>in</code> is exists in the list. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif ( 1  in intList) bitVal_0 = 1;           //  bitVal_0: 0 -&gt; 1\nif ( 0  in intList) bitVal_1 = 1;           //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intList) bitVal_2 = 1;           //  ILLEGAL (1)\n</code></pre></p> <ol> <li>Different data_type between LHS of <code>in</code> and the list's element on RHS of <code>in</code>.</li> </ol> <p>Warning</p> <p>Data_type of element on LHS of <code>in</code> should be SAME as the list's element on RHS of <code>in</code>.</p>"},{"location":"Collections/Lists/#foreach","title":"<code>foreach</code> statement","text":"<p>v2.2.0</p> <p>Iterates over the list's elements.</p> <p>Look at Procedural/<code>foreach</code> for more information. <pre><code>list&lt;int&gt; intList = {4, 5, 6};\nint intVal_0 = 0;\nint intVal_1 = 0;\nint intVal_2 = 0;\n\nforeach (i : intList[j]) {\n    intVal_0 = i;           //  intVal_0: 0 -&gt; 4 -&gt; 5 -&gt; 6\n    intVal_1 = j;           //  intVal_1: 0 -&gt; 0 -&gt; 1 -&gt; 2\n    intVal_2 = intList[j];  //  intVal_2: 0 -&gt; 4 -&gt; 5 -&gt; 6\n}\n</code></pre></p>"},{"location":"Collections/Lists/#size","title":"function int <code>size()</code>","text":"<p>v2.2.0</p> <p>Returns the number of elements in the list. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList.size();        //  intVal: 0 -&gt; 3\n</code></pre></p>"},{"location":"Collections/Lists/#clear","title":"function void <code>clear()</code>","text":"<p>v2.2.0</p> <p>Removes all elements from the list. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList.clear();                    //  intList: {1, 2, 3} -&gt; {}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#delete","title":"function &lt;data_type&gt; <code>delete(index)</code>","text":"<p>v2.2.0</p> <p>Moves out the element at the specified index, which must be a non-negative integer. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList.delete(1);     //  intVal: 0 -&gt; 2; intList: {1, 2, 3} -&gt; {1, 3}\nint intVal = intList.delete(5);     //  ILLEGAL (1)\n</code></pre></p> <ol> <li>The index is out of bounds.</li> </ol> <p>Warning</p> <p>The index must be smaller than <code>size()</code> of the list.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#insert","title":"function void <code>insert(index, element)</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element of <code>insert()</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element of <code>insert()</code>.</p> <p>Adds the element to the specified index, and all elements at and beyond the index are moved by one. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList.insert(1, 6);               //  intList: {1, 2, 3} -&gt; {1, 6, 2, 3}\nintList.insert(4, 7);               //  intList: {1, 6, 2, 3} -&gt; {1, 6, 2, 3, 7}\nintList.insert(9, 8);               //  ILLEGAL (1)\nintList.insert(0, \"1\");             //  ILLEGAL (2)\n</code></pre></p> <ol> <li>The index is larger than <code>size()</code> of the list.</li> <li>The data_type of elements are not the same.</li> </ol> <p>Warning</p> <p>The index should NOT larger than <code>size()</code> of the list.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#pop_front","title":"function &lt;data_type&gt; <code>pop_front()</code>","text":"<p>v2.2.0</p> <p>Moves out the first element from the list. Same as <code>delete(0)</code>. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList.pop_front();   //  intVal: 0 -&gt; 1; intList: {1, 2, 3} -&gt; {2, 3}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#push_front","title":"function void <code>push_front(element)</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element of <code>push_front()</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element of <code>push_front()</code>.</p> <p>Adds the element to the beginning of the list. Same as <code>insert(0, element)</code>. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList.push_front(4);              //  intList: {1, 2, 3} -&gt; {4, 1, 2, 3}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#pop_back","title":"function &lt;data_type&gt; <code>pop_back()</code>","text":"<p>v2.2.0</p> <p>Moves out the last element from the list. Same as <code>delete(size()-1)</code>. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList.pop_back();    //  intVal: 0 -&gt; 3; intList: {1, 2, 3} -&gt; {1, 2}\n</code></pre></p> Note <p>Method that modify contents can be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#push_back","title":"function void <code>push_back(element)</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element of <code>push_back()</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element of <code>push_back()</code>.</p> <p>Adds the element to the end of the list. Same as <code>insert(size()-1, element)</code>. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList.push_back(4);               //  intList: {1, 2, 3} -&gt; {1, 2, 3, 4}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>","text":"<p>v2.2.0</p> <p>Returns all elements to a <code>set</code>-type. <pre><code>list&lt;int&gt; intList = {1, 2, 1};\n\nset&lt;int&gt; intSet = intList.to_set(); //  intSet: {} -&gt; {1, 2}\n</code></pre></p>"},{"location":"Collections/Lists/#shuffle","title":"function void <code>shuffle()</code>","text":"<p>v2.3.0 v2.1</p> <p>Randomizes orders of elements. <pre><code>list&lt;int&gt; intList = {1, 2};\n\nintList.shuffle();                  //  intList: {1, 2} -&gt; {1, 2} or {2, 1}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/","title":"Map","text":"<p>v2.2.0</p>"},{"location":"Collections/Maps/#properties","title":"Properties","text":"<ul> <li>Unordered.</li> <li>Non-randomizable.</li> <li>Key, element and data_type can be any scalar or aggregate of scalars.</li> <li>Each key must be unique.</li> <li>Can be nested by any collection types (e.g., <code>array</code>, <code>list</code>, <code>map</code> or <code>set</code>).</li> </ul>"},{"location":"Collections/Maps/#declarations","title":"Declarations","text":"<p>v2.2.0</p> <p>Not support yet</p> <p>PSSGen: Not support <code>chandle</code> as data_type.</p> <p>Map can be declared by following syntax:</p> <p>map&lt;data_type, data_type&gt; identifier</p> <pre><code>map&lt;bit [4] , int    &gt; nibble2int  ;    //  nibble2int  : {}\nmap&lt;int     , bool   &gt; int2bool    ;    //  int2bool    : {}\nmap&lt;bool    , string &gt; bool2string ;    //  bool2string : {}\nmap&lt;string  , float32&gt; string2float;    //  string2float: {}\nmap&lt;float32 , int    &gt; float2int   ;    //  float2int   : {}\nmap&lt;eSTR2NUM, int    &gt; enum2int    ;    //  enum2int    : {} (1)\n</code></pre> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Maps/#initialization-assignment","title":"Initialization Assignment","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as key and element in initialization assignment.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as key or element in initialization assignment.</p> <p>Map can be assigned at declaration; otherwise, it will be initialized to empty aggregate literal (<code>{}</code>). <pre><code>map&lt;bit [4] , int    &gt; nibble2int   = {4'b1110:3      , 4'b0110:2     };\nmap&lt;int     , bool   &gt; int2bool     = {      4:true   ,       5:false };\nmap&lt;bool    , string &gt; bool2string  = {  false:\"FALSE\",    true:\"TRUE\"};\nmap&lt;string  , float32&gt; string2float = {  \"2.1\":2.1    ,   \"2.2\":2.2   };\nmap&lt;float32 , int    &gt; float2int    = {    2.4:2      ,     2.6:3     };\nmap&lt;eSTR2NUM, int    &gt; enum2int     = {    ONE:1      ,     TWO:2     }; // (1)!\n</code></pre></p> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Maps/#map-operators","title":"Map Operators","text":"Operator Description <code>[]</code> Used to access a specific element of a map by given key. <code>=</code> Create a copy of the <code>map</code>-type expression on the RHS and assigns it to the map on the LHS. <code>==</code> Evaluates to true if both sizes are equal and all elements with corresponding keys are equal. <code>!=</code> Evaluates to true whether both sizes are not equal or if any element with corresponding key is not equal. <code>foreach</code> Iterates over the map's elements."},{"location":"Collections/Maps/#map-methods","title":"Map Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the map. <code>clear()</code> Removes all *element\"s from the map. &lt;data_type&gt; <code>delete(key)</code> Moves out the element by the specified key, which must exists in the map. <code>insert(key, element)</code> Adds the element with the specified key. set&lt;data_type&gt; <code>keys()</code> Returns all keys to a <code>set</code>-type. list&lt;data_type&gt; <code>values()</code> Returns all elements to a <code>list</code>-type."},{"location":"Collections/Maps/#index","title":"Index operator <code>[]</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as key and element for index operator <code>[]</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as key or element for index operator <code>[]</code>.</p> <p>Used to access a specific element of a map by given key. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nint intVal = string2int[\"2\"];   //  intVal: 0 -&gt; 2;\nint intVal = string2int[\"3\"];   //  ILLEGAL (1)\nint intVal = string2int[ 1 ];   //  ILLEGAL (2)\n</code></pre></p> <ol> <li>The key <code>\"3\"</code> not exist.</li> <li>The data_type of index and key are not the same.</li> </ol> <p>Warning</p> <p>When used to reference an element in the map, the key should be exists.</p> Note <p>When used at LHS for assignment, the key will be added if not exists. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nstring2int[\"3\"] = 3;    //  string2int: {\"1\":0, \"2\":2} -&gt; {\"1\":0, \"2\":2, \"3\":3}\n</code></pre></p> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#assignment","title":"Assignment operator <code>=</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as key and element for assignment operator <code>=</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as key or element for assignment operator <code>=</code>.</p> <p>Creates a copy of the <code>map</code>-type expression on the RHS and assigns it to the map on the LHS. Last element will be used if there have multiple elements with same key in the expression. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nstring2int = {\"3\":3, \"4\":4};    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"3\":3, \"4\":4}\nstring2int = {3:\"3\", 4:\"4\"};    //  ILLEGAL (1)\n</code></pre></p> <ol> <li>The <code>data_type</code>s are not same as declaration of the map.</li> </ol> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#equality","title":"Equality operator <code>==</code>","text":"<p>v2.2.0</p> <p>Evaluates to true if both sizes are equal and all elements with corresponding keys are equal. <pre><code>map&lt;string, int   &gt; map_0 = {\"1\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_1 = {\"1\":0  , \"2\":2  };\nmap&lt;string, int   &gt; map_2 = {\"0\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_3 = {\"2\":2  , \"1\":1  };\nmap&lt;string, int   &gt; map_4 = {\"1\":1           };\nmap&lt;int   , string&gt; map_5 = {  1:\"1\",   2:\"2\"};\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3, bitVal_4, bitVal_5;\nif (map_0 == map_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 1 (1)\nif (map_0 == map_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 0 (2)\nif (map_0 == map_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 0 (3)\nif (map_0 == map_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 1 (4)\nif (map_0 == map_4) bitVal_4 = 1;   //  bitVal_4: 0 -&gt; 0 (5)\nif (map_0 == map_5) bitVal_5 = 1;   //  ILLEGAL (6)\n</code></pre></p> <ol> <li>Equalize size and all elements with corresponding keys.</li> <li>Inequalize any element with corresponding key.</li> <li>Inequalize any element with corresponding key.</li> <li>Equalize size and all elements with corresponding keys.</li> <li>Inequalize size.</li> <li>Different data_type of key or element are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of key or element of two maps should NOT be compared.</p>"},{"location":"Collections/Maps/#inequality","title":"Inequality operator <code>!=</code>","text":"<p>v2.2.0</p> <p>Evaluates to true whether both sizes are not equal or if any element with corresponding key is not equal. <pre><code>map&lt;string, int   &gt; map_0 = {\"1\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_1 = {\"1\":0  , \"2\":2  };\nmap&lt;string, int   &gt; map_2 = {\"0\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_3 = {\"2\":2  , \"1\":1  };\nmap&lt;string, int   &gt; map_4 = {\"1\":1           };\nmap&lt;int   , string&gt; map_5 = {  1:\"1\",   2:\"2\"};\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3, bitVal_4, bitVal_5;\nif (map_0 != map_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 0 (1)\nif (map_0 != map_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 1 (2)\nif (map_0 != map_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 1 (3)\nif (map_0 != map_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 0 (4)\nif (map_0 != map_4) bitVal_4 = 1;   //  bitVal_4: 0 -&gt; 1 (5)\nif (map_0 != map_5) bitVal_5 = 1;   //  ILLEGAL (6)\n</code></pre></p> <ol> <li>Equalize size and all elements with corresponding keys.</li> <li>Inequalize any element with corresponding key.</li> <li>Inequalize any element with corresponding key.</li> <li>Equalize size and all elements with corresponding keys.</li> <li>Inequalize size.</li> <li>Different data_type of key or element are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of key or element of two maps should NOT be compared.</p>"},{"location":"Collections/Maps/#foreach","title":"<code>foreach</code> statement","text":"<p>v2.2.0</p> <p>Iterates over the map's elements.</p> <p>Look at Procedural/<code>foreach</code> for more information. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\nint    intVal_0 = 0;\nstring intVal_1 = \"\";\nint    intVal_2 = 0;\n\nforeach (i : string2int[j]) {\n    intVal_0 = i;               //  intVal_0: 0  -&gt;  1  -&gt;  2\n    intVal_1 = j;               //  intVal_1: \"\" -&gt; \"1\" -&gt; \"2\"\n    intVal_2 = string2int[j];   //  intVal_2: 0  -&gt;  1  -&gt;  2\n}\n</code></pre></p>"},{"location":"Collections/Maps/#size","title":"function int <code>size()</code>","text":"<p>v2.2.0</p> <p>Returns the number of elements in the map. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nint intVal = string2int.size(); //  intVal: 0 -&gt; 2\n</code></pre></p>"},{"location":"Collections/Maps/#clear","title":"function void <code>clear()</code>","text":"<p>v2.2.0</p> <p>Removes all elements from the map. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nstring2int.clear(); //  string2int: {\"1\":1, \"2\":2} -&gt; {}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#delete","title":"function &lt;data_type&gt; <code>delete(data_type key)</code>","text":"<p>v2.2.0</p> <p>Moves out the element by the specified key, which must exists in the map. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nmap.delete(\"1\");    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"2\":2}\nmap.delete(\"3\");    //  ILLEGAL (1)\n</code></pre></p> <ol> <li>The key <code>\"3\"</code> is not exist.</li> </ol> <p>Warning</p> <p>The key should be exists in the map.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#insert","title":"function void <code>insert(data_type key, data_type element)</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as key and element of <code>insert()</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as key or element of <code>insert()</code>.</p> <p>Adds the element with the specified key. The element will be replaced if the key already exists. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nstring2int.insert(\"1\", 0  );    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"1\":0, \"2\":2}\nstring2int.insert(\"3\", 3  );    //  string2int: {\"1\":0, \"2\":2} -&gt; {\"1\":0, \"2\":2, \"3\":3}\nstring2int.insert(\"4\", 4.0);    //  ILLEGAL (1)\nstring2int.insert(5  , 5  );    //  ILLEGAL (2)\n</code></pre></p> <ol> <li>The data_type of element is not same.</li> <li>The data_type of key is not same.</li> </ol> <p>Waring</p> <p>The data_type of key or element should be same as the map's declaration.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#keys","title":"function set&lt;data_type&gt; <code>keys()</code>","text":"<p>v2.2.0</p> <p>Not support yet</p> <p>PSSGen: Not support <code>float32</code>, <code>float64</code>, and <code>chandle</code> as key for <code>keys()</code> method.</p> <p>Returns all keys to a <code>set</code>-type. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2, \"2.5\":2};\n\nset&lt;string&gt; stringSet = string2int.keys();  //  stringSet: {} -&gt; {\"1\", \"2\", \"2.5\"}\n</code></pre></p>"},{"location":"Collections/Maps/#values","title":"function list&lt;data_type&gt; <code>values()</code>","text":"<p>v2.2.0</p> <p>Not support yet</p> <p>PSSGen: Not support <code>float32</code>, <code>float64</code>, and <code>chandle</code> as element for <code>values()</code> method.</p> <p>Returns all elements to a <code>list</code>-type. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2, \"2.5\":2};\n\nlist&lt;int&gt; intList = string2int.values();    //  intList: {} -&gt; {1, 2, 2}\n</code></pre></p>"},{"location":"Collections/Sets/","title":"Set","text":"<p>v2.2.0</p>"},{"location":"Collections/Sets/#properties","title":"Properties","text":"<ul> <li>Unordered.</li> <li>Non-randomizable.</li> <li>Element can be any scalar or aggregate of scalars.</li> <li>Each element must be unique.</li> <li>Can be nested by any collection types (e.g., <code>array</code>, <code>list</code>, <code>map</code> or <code>set</code>).</li> </ul>"},{"location":"Collections/Sets/#declarations","title":"Declarations","text":"<p>v2.2.0</p> <p>Not support yet</p> <p>PSSGen: Not support <code>chandle</code> as data_type.</p> <p>Set can be declared by following syntax:</p> <p>set&lt;data_type&gt; identifier</p> <pre><code>set&lt;bit [4] &gt; nibbleSet;    //  nibbleSet: {}\nset&lt;int     &gt; intSet   ;    //  intSet   : {}\nset&lt;bool    &gt; boolSet  ;    //  boolSet  : {}\nset&lt;string  &gt; stringSet;    //  stringSet: {}\nset&lt;float32 &gt; floatSet ;    //  floatSet : {}\nset&lt;eSTR2NUM&gt; enumSet  ;    //  enumSet  : {} (1)\n</code></pre> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Sets/#initialization-assignment","title":"Initialization Assignment","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element in initialization assignment.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element in initialization assignment.</p> <p>Set can be assigned at declaration; otherwise, it will be initialized to empty aggregate literal (<code>{}</code>). <pre><code>set&lt;bit [4] &gt; nibbleSet = {4'b0001, 4'b0010};\nset&lt;int     &gt; intSet    = {      1, 2      };\nset&lt;bool    &gt; boolSet   = {  false, true   };\nset&lt;string  &gt; stringSet = {    \"1\", \"2\"    };\nset&lt;float32 &gt; floatSet  = {    1.0, 2.0    };\nset&lt;eSTR2NUM&gt; enumSet   = {    ONE, TWO    };   // (1)!\n</code></pre></p> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Sets/#set-operators","title":"Set Operators","text":"Operator Description <code>=</code> Create a copy of the <code>set</code>-type expression on the RHS and assigns it to the set on the LHS. <code>==</code> Evaluetes to true if both sizes are equal and have exactly same elements. <code>!=</code> Evaluetes to true whether both sizes are not equal or do not have exactly same elements. <code>in</code> Evaluetes to true if element on LHS of <code>in</code> is exists in the set. <code>foreach</code> Iterates over the set's elements."},{"location":"Collections/Sets/#set-methods","title":"Set Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the set. <code>clear()</code> Removes all elements from the set. <code>delete(data_type element)</code> Remove the elements from the set. <code>insert(data_type element)</code> Adds the element to the set. list&lt;data_type&gt; <code>to_list()</code> Returns all elements to a <code>list</code>-type."},{"location":"Collections/Sets/#assignment","title":"Assignment operator <code>=</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element for assignment operator <code>=</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element for assignment operator <code>=</code>.</p> <p>Create a copy of the <code>set</code>-type expression on the RHS and assigns it to the set on the LHS. Same elements in the RHS will be merged automatically and appear only once in the set. <pre><code>set&lt;int&gt; intSet;\n\nintSet = {1, 2};    //  intSet: {}     -&gt; {1, 2}\nintSet = {3, 3, 4}; //  intSet: {1, 2} -&gt; {3, 4} (1)\n</code></pre></p> <ol> <li>Same element will appear only once.</li> </ol> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Sets/#equality","title":"Equality operator <code>==</code>","text":"<p>v2.2.0</p> <p>Evaluetes to true if both sizes are equal and have exactly same elements. <pre><code>set&lt;int   &gt; set_0 = { 1 ,  2      };\nset&lt;int   &gt; set_1 = { 2 ,  1      };\nset&lt;int   &gt; set_2 = { 1 ,  2 ,  3 };\nset&lt;string&gt; set_3 = {\"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (set_0 == set_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 1 (1)\nif (set_0 == set_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 1 (2)\nif (set_0 == set_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 0 (3)\nif (set_0 == set_3) bitVal_3 = 1;   //  ILLEGAL (4)\n</code></pre></p> <ol> <li>Equalize size and all elements.</li> <li>Equalize size and all elements in different order.</li> <li>Inequalize size.</li> <li>Different data_type are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of two sets should NOT be compared.</p>"},{"location":"Collections/Sets/#inequality","title":"Inequality operator <code>!=</code>","text":"<p>v2.2.0</p> <p>Evaluetes to true whether both sizes are not equal or do not have exactly same elements. <pre><code>set&lt;int   &gt; set_0 = { 1 ,  2      };\nset&lt;int   &gt; set_1 = { 2 ,  1      };\nset&lt;int   &gt; set_2 = { 1 ,  2 ,  3 };\nset&lt;string&gt; set_3 = {\"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (set_0 != set_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 0 (1)\nif (set_0 != set_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 0 (2)\nif (set_0 != set_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 1 (3)\nif (set_0 != set_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 1 (4)\n</code></pre></p> <ol> <li>Equalize size, and all elements.</li> <li>Equalize size, and all elements in different order.</li> <li>Inequalize size.</li> <li>Different data_type are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of two sets should NOT be compared.</p>"},{"location":"Collections/Sets/#in","title":"Set membership operator <code>in</code>","text":"<p>v2.2.0</p> <p>Not support yet</p> <p>PSSGen: Not support <code>float32</code>, <code>float64</code>, and <code>chandle</code> as element.</p> <p>Evaluetes to true if element on LHS of <code>in</code> is exists in the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif ( 1  in intSet) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1\nif ( 3  in intSet) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intSet) bitVal_2 = 1;    //  ILLEGAL (1)\n</code></pre></p> <ol> <li>Different data_type between LHS of <code>in</code> and the set's element on RHS of <code>in</code>.</li> </ol> <p>Warning</p> <p>Data_type of element on LHS of <code>in</code> should be SAME as the set's element on RHS of <code>in</code>.</p>"},{"location":"Collections/Sets/#foreach","title":"<code>foreach</code> statement","text":"<p>v2.2.0</p> <p>Iterates over the set's elements.</p> <p>Look at Procedural/<code>foreach</code> for more information. <pre><code>set&lt;int&gt; intSet = {3, 4};\nint intVal = 0;\n\nforeach (i : intSet) {\n    intVal = i;     //  intVal: 0 -&gt; 3 -&gt; 4 or 0 -&gt; 4 -&gt; 3\n}\n</code></pre></p> Warning <p>For <code>set</code>-type, index variable of <code>foreach</code> statament should NOT be used to specify <code>set</code> elements. <pre><code>foreach (intSet[i]) {}  //  ILLEGAL\n</code></pre></p>"},{"location":"Collections/Sets/#size","title":"function int <code>size()</code>","text":"<p>v2.2.0</p> <p>Returns the number of elements in the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nint intVal = intSet.size(); //  intVal: 0 -&gt; 2\n</code></pre></p>"},{"location":"Collections/Sets/#clear","title":"function void <code>clear()</code>","text":"<p>v2.2.0</p> <p>Removes all elements from the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.clear(); // intSet: {1, 2} -&gt; {}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Sets/#delete","title":"function void <code>delete(data_type element)</code>","text":"<p>v2.2.0</p> <p>Removes the elements from the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.delete( 2 ); //  intSet: {1, 2} -&gt; {1}\nintSet.delete( 3 ); //  ILLEGAL (1)\nintSet.delete(\"1\"); //  ILLEGAL (2)\n</code></pre></p> <ol> <li>The element is not exist in the set.</li> <li>Data-type of the element is not same as the set.</li> </ol> <p>Warning</p> <p>The element need to deleted should exists in the set.</p> Note <p>Different to <code>list</code>-type or <code>map</code>-type, <code>delete(data_type element)</code> of <code>set</code>-type will not return the element.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Sets/#insert","title":"function void <code>insert(data_type element)</code>","text":"<p>v2.2.0</p> <p>PSSGen: Support <code>bit</code>, <code>int</code>, and <code>string</code> as element of <code>insert()</code>.</p> <p>Not support yet</p> <p>PSSGen: Not support <code>bool</code>, <code>enum</code>, <code>float32</code>, <code>float64</code>, <code>chandle</code>, and <code>struct</code> as element of <code>insert()</code>.</p> <p>Adds the element to the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.insert( 3 ); //  intSet: {1, 2}    -&gt; {1, 2, 3}\nintSet.insert( 2 ); //  intSet: {1, 2, 3} -&gt; {1, 2, 3}\nintSet.insert(\"4\"); //  ILLEGAL (1)\n</code></pre></p> <ol> <li>Data-type of the element is not same as the set.</li> </ol> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Sets/#to_list","title":"function list&lt;data_type&gt; <code>to_list()</code>","text":"<p>v2.2.0</p> <p>Returns all elements to a <code>list</code>-type. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nlist&lt;int&gt; intList = intSet.to_list();   //  intList: {} -&gt; {1, 2}\n</code></pre></p>"},{"location":"DataTypes/","title":"Data Types","text":""},{"location":"DataTypes/#datatypes_scalar","title":"Scalar Type","text":"Scalar Type Randomizable <code>bit</code>v1.0.0  Randomizable <code>int</code>v1.0.0  Randomizable <code>bool</code>Not support yet  Randomizable <code>enum</code>v1.0.0  Randomizable <code>string</code>v1.0.0  Randomizable <code>float32</code>Not support yet v2.1 <code>float64</code>Not support yet v2.1 <code>chandle</code>Not support yet"},{"location":"DataTypes/#datatypes_aggregate","title":"Aggregate","text":"Aggregate Type Randomizable <code>array</code>v2.2.0  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code> <code>list</code>v2.2.0  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code>Not support yet v2.1 <code>map</code>v2.2.0 <code>set</code>v2.2.0 <code>struct</code>v1.0.0  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code> <p>Aggregate may be nested.</p>"},{"location":"DataTypes/#datatypes_non_aggregate","title":"Non-aggregate","text":"<ul> <li><code>component</code></li> <li><code>action</code></li> <li><code>buffer</code></li> <li><code>stream</code></li> <li><code>state</code></li> <li><code>resource</code></li> </ul>"},{"location":"DataTypes/IntegerTypes/","title":"Integer Types","text":""},{"location":"DataTypes/IntegerTypes/#datatypes_integertypes_bit","title":"Bit","text":"<p> v1.0.0 </p> <p><code>bit</code> is a integer data type with default properties: unsigned, 1-bit width, {0, 1} domain.</p>"},{"location":"DataTypes/IntegerTypes/#declare-a-bit","title":"Declare a bit","text":"<pre><code>bit singleBit;\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#declare-8-bits-wide-bit-type","title":"Declare 8-bits wide <code>bit</code> type","text":"<p>Possible values specified by bit width are {0..(2<sup>width</sup>-1)}</p> single bounddual bound <pre><code>bit [8] singleByte;     //  possible values: {0..127};\n</code></pre> <pre><code>bit [7:0] singleByte;   //  possible values: {0..127};\n</code></pre> <p>lower bound must be <code>0</code></p> <p>dual bounds may be removed in future version</p>"},{"location":"DataTypes/IntegerTypes/#declared-with-specified-value-domain","title":"Declared with specified value domain","text":"<p> Not support yet </p> <p>Values of variable are within intersection of possible values by width and value domain. <pre><code>bit [8] in [0, 1, 5]             singleByte;    //  value domain: {0, 1, 5}\nbit [8] in [..2]                 singleByte;    //  value domain: {0, 1, 2}\nbit [8] in [6..8]                singleByte;    //  value domain: {6, 7, 8}\nbit [8] in [254..]               singleByte;    //  value domain: {254, 255}\nbit [8] in [5, ..2, 6..8, 254..] singleByte;    //  value domain: {0, 1, 2, 5, 6, 7, 8, 254, 255}\n</code></pre></p> <p>Tip</p> <p>Specify value domain is useful for random variable. Following examples are equalize:</p> value domain within declarationvalue domain within <code>constraint</code> <pre><code>rand bit [8] in [5, ..2, 6..8, 253..] singleByte;\n</code></pre> <pre><code>rand bit [8] singleByte;\nconstraint {\n    singleByte in [5, ..2, 6..8, 253..];\n}\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#datatypes_integertypes_integer","title":"Integer","text":"<p> v1.0.0 </p> <p><code>int</code> is a integer data type with default properties: signed, 32-bits width, {-2<sup>31</sup>..(2<sup>31</sup>-1)} domain.</p>"},{"location":"DataTypes/IntegerTypes/#declare-an-integer","title":"Declare an integer:","text":"<pre><code>int int32;\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#declare-8-bits-wide-int-type","title":"Declare 8-bits wide <code>int</code> type","text":"<p>Possible values specified by bit width are {-2<sup>width-1</sup>..(2<sup>width-1</sup>-1)}</p> single bounddual bound <pre><code>int [8] int8;       //  possible values: {-128..127}\n</code></pre> <pre><code>int [7:0] int8;     //  possible values: {-128..127}\n</code></pre> <p>lower bound must be <code>0</code></p> <p>dual bounds may be removed in future version</p>"},{"location":"DataTypes/IntegerTypes/#declared-with-specified-value-domain_1","title":"Declared with specified value domain","text":"<p> Not support yet </p> <p>Values of variable are within intersection of possible values by width and value domain. <pre><code>int [8] in [0, 1, 5]                  int8; //  value domain: {0, 1, 5}\nint [8] in [..(-127)]                 int8; //  value domain: {-128, -127}\nint [8] in [6..8]                     int8; //  value domain: {6, 7, 8}\nint [8] in [126..]                    int8; //  value domain: {126, 127}\nint [8] in [5, ..(-127), 6..8, 253..] int8; //  value domain: {-128, -127, 5, 6, 7, 8, 126, 127}\n</code></pre></p> <p>Tip</p> <p>Specify value domain is useful for random variable. Following examples are equalize:</p> value domain within declarationvalue domain within <code>constraint</code> <pre><code>rand int [8] in [5, ..(-127), 6..8, 253..] int8;\n</code></pre> <pre><code>rand int [8] int8;\nconstraint {\n    int8 in [5, ..(-127), 6..8, 253..];\n}\n</code></pre>"},{"location":"Operator/","title":"Operators and Expressions","text":""},{"location":"Operator/#assignment-operators","title":"Assignment Operators","text":"<p>WIP</p>"},{"location":"Operator/#expression-operators-and-data-types","title":"Expression operators and data types","text":"Operator token Operator name Operator data types Result data type <code>?:</code> Conditional operator Any plain-data type or reference type Same as operands <code>-</code> Unary arithmetic negation operator Numeric Same as operand <code>~</code> Unary bitwise negation operator Numeric Same as operand <code>!</code> Unary Boolean negation operator Boolean Boolean <code>&amp; | ^</code> Unary bitwise reduction operators Numeric 1-bit <code>+ - * / % **</code> Binary arithmetic operators Numeric 1-bit <code>&amp; | ^</code> Binary bitwise operators Numeric 1-bit <code>&gt;&gt; &lt;&lt;</code> Binary shift operators Numeric Same as left operand <code>&amp;&amp; ||</code> Binary Boolean logical operators Boolean Same as operands <code>&lt; &lt;= &gt; &gt;=</code> Binary relational operators Numeric Boolean <code>== !=</code> Binary logical equality operators Any plain-data type or reference type Boolean <code>cast</code> Data type conversion operator Numeric, Boolean, enum Casting type <code>in</code> Binary set membership operator Any plain-data type Boolean <code>[expression]</code> Index operator Array, list, map Same as element of collection <code>[expression]</code> Bit-select operators Numeric Numeric <code>[expression:expression]</code> Part-select operator Numeric Numeric"},{"location":"Operator/#operator-precedence-and-associativity","title":"Operator precedence and associativity","text":"Operator Associativity Precesence <code>()</code> <code>[]</code> Left 1 (Highest) <code>cast</code> Right 2 <code>-</code> <code>!</code> <code>~</code> <code>&amp;</code> <code>|</code> <code>^</code> (unary) 2 <code>**</code> Left 3 <code>*</code> <code>/</code> <code>%</code> Left 4 <code>+</code> <code>-</code> (binary) Left 5 <code>&lt;&lt;</code> <code>&gt;&gt;</code> Left 6 <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>in</code> Left 7 <code>==</code> <code>!=</code> Left 8 <code>&amp;</code> (binary) Left 9 <code>^</code> (binary) Left 10 <code>|</code> (binary) Left 11 <code>&amp;&amp;</code> Left 12 <code>||</code> Left 13 <code>?:</code> (conditional operator) Right 14 (Lowest)"},{"location":"Operator/BinaryBitwise/","title":"Binary Bitwise Operators","text":"<p>PSS supports 3 basic bitwise operators: 1. Bitwise AND <code>&amp;</code> 2. Bitwise OR <code>|</code> 3. Bitwise XOR <code>^</code></p>"},{"location":"Operator/BinaryBitwise/#constant-op-constant","title":"CONSTANT op CONSTANT","text":"<pre><code>bit [8] byteAND = 8'b0110_1001 &amp; 8'b0000_1111;  //  byteAND: 0 -&gt; 8'b0000_1001\nbit [8] byteOR  = 8'b0110_1001 | 8'b0000_1111;  //  byteOR : 0 -&gt; 8'b0110_1111\nbit [8] byteXOR = 8'b0110_1001 ^ 8'b0000_1111;  //  byteXOR: 0 -&gt; 8'b0110_0110\n</code></pre>"},{"location":"Operator/Expressions/","title":"Primary Expressions","text":""},{"location":"Operator/Expressions/#primary_expressions_bit-selects","title":"Bit-selects","text":"<p> v2.2.0 </p> <p>Used to select a particular bit from integer variable or constant by specified an index.</p> <p>Get a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\n\nbit bitVal = nibbleVal[1];      //  bitVal: 0 -&gt; 1\n</code></pre></p> <p>Assign a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\n\nnibbleVal[1] = 0;               //  nibbleVal: 0b0011 -&gt; 0b0001\n</code></pre></p> <p>Assign a bit of variable by a non-zero integer: <pre><code>bit [4] nibbleVal = 4'b0011;\n\nnibbleVal[2] = 2'b10;           //  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> <p>Operate a bit of variable by another bit: <pre><code>bit [4] nibbleVal = 4'b0011;\n\nnibbleVal[2] |= nibbleVal[1];   //  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\n\nbit bitVal = nibbleVal[10];     //  ILLEGAL (1)\nnibbleVal[10] = 1;              //  ILLEGAL (2)\nnibbleVal[-1] = 1;              //  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>The index is larger than bit-width of variable.</li> <li>The index is larger than bit-width of variable.</li> <li>The index should NOT be negative.</li> </ol> <p>Warning</p> <p>The index should be a non-negative integer and should NOT access out-of-bounds.</p>"},{"location":"Operator/Expressions/#primary_expressions_part-selects","title":"Part-selects","text":"<p> Not support yet </p> <p>Used to select a fixed range of contiguous bits of variable by specified dual-bounds index.</p> <p>Get 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\n\nbit [2] bitVal = nibbleVal[1:0];    //  bitVal: 0b00 -&gt; 0b11\nbit [2] bitVal = nibbleVal[0:1];    //  ILLEGAL SYNTAX (1)\n</code></pre></p> <ol> <li>LSB of index shall be smaller than MSB.</li> </ol> <p>Assign 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\n\nnibbleVal[1:0] = 2'b00;             //  nibbleVal: 0b0011 -&gt; 0b0000\n</code></pre></p> <p>Operate 2 bits of variable by another 2 bits: <pre><code>bit [4] nibbleVal = 4'b0011;\n\nnibbleVal[3:2] |= nibbleVal[1:0];   //  nibbleVal: 0b0011 -&gt; 0b1111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\n\nbit [2] bitVal = nibbleVal[4:3];    //  ILLEGAL (1)\nnibbleVal[4:3] = 2'b01;             //  ILLEGAL (2)\nnibbleVal[0:-1] = 2'b01;            //  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>MSB of index is larger than bit-width of variable.</li> <li>MSB of index is larger than bit-width of variable.</li> <li>LSB of index should NOT be negative.</li> </ol> <p>Warning</p> <p>The indexes should be a non-negative integer and should NOT access out-of-bounds. The MSB of index should larger than LSB of index.</p>"},{"location":"Operator/Expressions/#primary_expressions_indexing","title":"Selecting an element from a collection (indexing)","text":"<p> v2.2.0 </p> <p>Used as index operator <code>[]</code> of <code>array</code>, <code>list</code>, and <code>map</code> collections.</p> <p>Get an element of collection (e.g., <code>array</code>, <code>list</code>, <code>map</code>): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[0]  ;  //  nibbleArrayVal: 0 -&gt; 0b1100\nbit [4] nibbleListVal  = nibbleList[1]   ;  //  nibbleListVal : 0 -&gt; 0b0110\nbit [4] nibbleMapVal   = nibbleMap[\"ONE\"];  //  nibbleMapVal  : 0 -&gt; 0b1100\n</code></pre></p> <p>Assign an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nnibbleArray[0]   = 4'b0011;  //  nibbleArray[0]  : 0b1100 -&gt; 0b0011\nnibbleList[0]    = 4'b0011;  //  nibbleList[0]   : 0b1100 -&gt; 0b0011\nnibbleMap[\"ONE\"] = 4'b0001;  //  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b0001\nnibbleMap[\"TWO\"] = 4'b0110;  //  nibbleMap[\"TWO\"]: {} -&gt; 0b0110 (1)\n</code></pre></p> <ol> <li><code>map</code> will add the element if no existed.</li> </ol> <p>Operate an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100,        4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100,        4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100, \"TWO\": 4'b0110};\n\nnibbleArray[0]   |= nibbleArray[1]  ;  //  nibbleArray[0]  : 0b1100 -&gt; 0b1110\nnibbleList[0]    |= nibbleList[1]   ;  //  nibbleList[0]   : 0b1100 -&gt; 0b1110\nnibbleMap[\"ONE\"] |= nibbleMap[\"TWO\"];  //  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b1110\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[2]  ;  //  ILLEGAL (1)\nbit [4] nibbleListVal  = nibbleList[2]   ;  //  ILLEGAL (2)\nbit [4] nibbleMapVal   = nibbleMap[\"TWO\"];  //  ILLEGAL (3)\n</code></pre> <ol> <li>The index must be inbound of size.</li> <li>The index must be inbound of size.</li> <li>The element must be exist in the <code>map</code>.</li> </ol>"},{"location":"Operator/Expressions/#usage","title":"Usage","text":"Access bit of an array <pre><code>array&lt;bit [4], 2&gt; nibbleArray = {4'b1100, 4'b0110};\n\nbit bitOnArray_0_2 = nibbleArray[0][2]; //  bitOnArray_0_2: 0 -&gt; 1\nnibbleArray[1][0] = 1;                  //  nibbleArray[1]: 0b0110 -&gt; 0b0111\n</code></pre>"},{"location":"Procedural/","title":"Procedural","text":""},{"location":"Procedural/#void","title":"<code>void</code> Function Calls","text":"<p>Declare a function that no return value.</p> <p>WIP</p>"},{"location":"Procedural/#return","title":"<code>return</code> Statement","text":"<p>Returns a value to the caller from a function or <code>exec</code> block. Syntax:</p> <p>return expression ;</p> <ul> <li>expression : An optional value need for returned to the caller.</li> </ul>"},{"location":"Procedural/#repeat","title":"<code>repeat</code> Statement","text":"<p>Executes procedural_stmt repeatedly by specified the number of iteration. Syntax:</p> <p>repeat (index_identifier : expression) procedural_stmt</p> <ul> <li>index_identifier : An optional index-variable identifier can be specified that ranges from <code>0</code> to <code>*iteration* - 1</code>.</li> <li>expression : Specify iteration by a non-negative integer (e.g., <code>int</code> or <code>bit</code>).</li> <li>procedural_stmt : Iterated by the number of iteration. Not executed if iteration is <code>0</code>.</li> </ul> <pre><code>int intVal = 0;\n\nrepeat (i : 3) {\n    intVal = i;     //  intVal: 0 -&gt; 1 -&gt; 2 -&gt; 3\n}\n</code></pre>"},{"location":"Procedural/#repeat_while","title":"<code>repeat</code>-<code>while</code> Statement","text":"<p>Executes procedural_stmt repeatedly as long as the expression is true. Syntax:</p> <p>repeat procedural_stmt while (expression);</p> <ul> <li>procedural_stmt : Iterated so long as the expression is true.</li> <li>expression : Evaluates true or false everytime after procedural_stmt.</li> </ul> <pre><code>int intVal = 0;\n\nrepeat {\n    intVal += 1;    //  intVal: 0 -&gt; 1 -&gt; 2 -&gt; 3\n} while (intVal &lt; 1);\n</code></pre>"},{"location":"Procedural/#while","title":"<code>while</code> Statement","text":"<p>Executes procedural_stmt repeatedly as long as the expression is true. Syntax:</p> <p>while (expression) procedural_stmt</p> <ul> <li>procedural_stmt : Iterated so long as the expression is true.</li> <li>expression : Evaluates true or false everytime before procedural_stmt.</li> </ul> <pre><code>int intVal = 0;\n\nwhile (intVal &lt; 3) {\n    intVal += 1;    //  intVal: 0 -&gt; 1 -&gt; 2 -&gt; 3\n}\n</code></pre>"},{"location":"Procedural/#foreach","title":"<code>foreach</code> Statement","text":"<p>Executes procedural_stmt for each element of the expression. Syntax:</p> <p>foreach (iterator_identifier : expression [index_identifier]) procedural_stmt</p> <ul> <li>iterator_identifier : An optional iterator-variable identifier with collection element type, an is an lias to current element.</li> <li>index_identifier : An optional index-variable identifier can be specified that ranges from <code>0</code> to <code>size() - 1</code> when expression is <code>array</code>-type or <code>list</code>-type; or can be specified of all keys when expression is <code>map</code>-type.</li> <li>expression : A collection type (e.g., <code>array</code>, <code>list</code>, <code>map</code>, or <code>set</code>).</li> <li>procedural_stmt : Iterated by the number of <code>size()</code> of the expression.</li> </ul> <p>Warning</p> <ul> <li>For <code>set</code>-type, index_identifier should NOT be specified.</li> <li>At least one of iterator_identifier or index_identifier should be specified.</li> <li>Both iterator_identifier and index_identifier should NOT be changed inside procedural_stmt.</li> </ul> Note <ul> <li>A colon (<code>:</code>) must be append after iterator_identifier if its specified.</li> <li>A pair of square brackets (<code>[]</code>) must be used to contain index_identifier if its specified.</li> <li>The order of keys are undetermined when expression is <code>map</code>-type.</li> </ul> <pre><code>array&lt;bit [4], 3&gt; nibbleArray = {4'd4, 4'd5, 4'd6};\nbit [4] nibbleVal = 0;\nint intVal = 0;\n\nforeach (i : intArray[j]) {\n    nibbleVal = i;  //  nibbleVal: 0 -&gt; 4'd4 -&gt; 4'd5 -&gt; 4'd6\n    intVal    = j;  //  intVal   : 0 -&gt;   0  -&gt;   1  -&gt;   2\n}\n</code></pre>"},{"location":"Procedural/#if_else","title":"<code>if</code>-<code>else</code> Statement","text":"<p>Executes procedural_stmt_for_true when expression is true. Syntax:</p> <p>if (expression) procedural_stmt_for_true else procedural_stmt_for_false</p> <ul> <li>expression : Evaluates true or false.</li> <li>procedural_stmt_for_true : Executed when the expression is true.</li> <li>procedural_stmt_for_false : An optional procedural will be executed when the expression is false.</li> </ul> <pre><code>int intVal = 3;\nbit bitVal = 0;\n\nif (intVal &gt; 0) {\n    bitVal = 1;     //  bitVal: 0 -&gt; 1\n}\nelse {\n    bitVal = 0;\n}\n</code></pre>"},{"location":"Procedural/#match","title":"<code>match</code> Statement","text":"<p>Executes procedural_stmt when corresponding range is match to the expression. Syntax:</p> <p>match (expression) {   [range] : procedural_stmt   [range] : procedural_stmt   ...   default : procedural_stmt }</p> <ul> <li>expression : The item to be evaluated.</li> <li>range : An open range list is compared to expression.</li> <li>procedural_stmt : Executed when expression matches any one in corresponding range.</li> <li>default : An optional procedural will be executed when not any range was matched.</li> </ul> <p>Warning</p> <ul> <li>Only one of ranges should be matched.</li> <li>The <code>default</code> must be exist and executed if no any range was matched.</li> </ul> <pre><code>int intVal = 3;\nbit [4] nibbleVal = 0;\n\nmatch (intVal) {\n    [..-1]       : nibbleVal = 4'b0001;\n    [0..9]       : nibbleVal = 4'b0010;\n    [10, 12, 14] : nibbleVal = 4'b0100; //  nibbleVal: 0 -&gt; 4'b0100\n    [100..]      : nibbleVal = 4'b1000;\n    default      : nibbleVal = 4'b1111;\n}\n</code></pre>"},{"location":"Procedural/#break","title":"<code>break</code> Statement","text":"<p>Continues execution after enclosing innermost loop construct. Syntax:</p> <p>break;</p> <p>Warning</p> <p>The <code>break</code> statement may only appear within loop statements (<code>repeat</code>, <code>repeat</code>-<code>while</code>, <code>while</code>, or <code>foreach</code>).</p> <pre><code>int intVal = 1;\n\nwhile (intVal &gt; 0) {\n    intVal += 1;    //  intVal: 0 -&gt; 1 -&gt; 2 -&gt; 3\n    if (intVal &gt; 2) break;\n}\n</code></pre>"},{"location":"Procedural/#continue","title":"<code>continue</code> Statement","text":"<p>Continues next loop iteration. Syntax:</p> <p>continue;</p> <p>Warning</p> <p>The <code>continue</code> statement may only appear within loop statements (<code>repeat</code>, <code>repeat</code>-<code>while</code>, <code>while</code>, or <code>foreach</code>).</p> <pre><code>int intVal = 0;\n\nrepeat (i : 3) {\n    if (i &lt; 2) continue;\n    intVal = i;     //  intVal: 0 -&gt; 2\n}\n</code></pre>"},{"location":"Procedural/#rand","title":"<code>rand</code> Statement","text":"<p>WIP</p>"},{"location":"Procedural/#exec","title":"<code>exec</code> Block","text":"<p>WIP</p>"},{"location":"Traversal/","title":"Traversal","text":""},{"location":"Traversal/#traversal-context","title":"Traversal Context","text":"Context Semantics <code>parallel</code> All array elements are scheduled for traversal in parallel. <code>schedule</code> All array elements are scheduled for traversal independently. <code>select</code> One array element is randomly selected and traversed. <code>sequence</code> All array elements are scheduled for traversal in sequence from <code>0</code> to <code>N-1</code>."},{"location":"Traversal/#traversal_parallel","title":"<code>parallel</code>","text":"<p>WIP</p>"},{"location":"Traversal/#traversal_schedule","title":"<code>schedule</code>","text":"<p>Both actions (i.e., sub with \"Hello\" and \"World\") in <code>schedule</code> block will be traversed in random order. <pre><code>action top {\n    activity {\n        schedule {\n            do sub with { str == \"Hello\"; };\n            do sub with { str == \"World\"; };\n        }\n    }\n}\n\naction sub {\n    rand string str;\n    exec body ASM = \"\"\"{{str}}\"\"\";\n}\n</code></pre></p> <p>There have two possible results:</p> \"Hello\" first\"World\" first <pre><code>Hello\nWorld\n</code></pre> <pre><code>World\nHello\n</code></pre>"},{"location":"Traversal/#traversal_select","title":"<code>select</code>","text":"<p>Only one action in <code>select</code> block will be chosen and traversed. <pre><code>action top {\n    activity {\n        select {\n            do sub with { str == \"Hello\"; };\n            do sub with { str == \"World\"; };\n        }\n    }\n}\n\naction sub {\n    rand string str;\n    exec body ASM = \"\"\"{{str}}\"\"\";\n}\n</code></pre></p> <p>There have two possible results:</p> \"Hello\" chosen\"World\" chosen <pre><code>Hello\n</code></pre> <pre><code>World\n</code></pre>"},{"location":"Traversal/#traversal_sequence","title":"<code>sequence</code>","text":"<p>WIP</p>"}]}