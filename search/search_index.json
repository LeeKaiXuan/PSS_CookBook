{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portable Test and Stimulus Standard (PSS) Cookbook","text":"<p>In this document, we summarize the LRM of PSS, and give you extra examples and tips.</p>"},{"location":"#reference","title":"Reference","text":"<ul> <li>LRM: PSS 2.0 Language Reference Manual</li> <li>LRM: PSS 2.1 Language Reference Manual</li> <li>AndesTech PSS Generator: PSSGen</li> </ul>"},{"location":"Collections/Arrays/","title":"Array","text":""},{"location":"Collections/Arrays/#declarations","title":"Declarations","text":"<p>Array has 2 declaration formats: <code>Template</code>, <code>Square</code>.</p> TemplateSquare <pre><code>array&lt;int    , 3&gt; intArray   ;  //  declare integer array with 3 elements\narray&lt;bit [8], 3&gt; byteArray  ;  //  declare byte array with 3 elements\narray&lt;string , 3&gt; stringArray;  //  declare string array with 3 elements\narray&lt;array&lt;int, 3&gt;, 2&gt; nestedArray;    //  declare nested array with 3x2 integer elements\n</code></pre> <pre><code>int     intArray    [3];        //  declare integer array with 3 elements\nbit [8] byteArray   [3];        //  declare byte array with 3 elements\nstring  stringArray [3];        //  declare string array with 3 elements\n// (1)!\n</code></pre> <ol> <li><code>square</code> format not support for declare nested array</li> </ol> <p>Declare array by <code>rand</code> keyword:</p> TemplateSquare <pre><code>rand array&lt;int, 3&gt; intArray;    //  declare integer array with 3 random elements\n</code></pre> <pre><code>rand int intArray [3];          //  declare integer array with 3 random elements\n</code></pre>"},{"location":"Collections/Arrays/#array-operators","title":"Array Operators","text":"Operator Description <code>[]</code> Used to access a specific element of an array. <code>=</code> Creates a copy of the <code>array</code>-type expression on the RHS and assigns it to the array on the LHS. <code>==</code> Evaluates to true if all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true if not all elements with corresponding indexes are equal. <code>in</code> It evaluates to true if the element specified on the left of the operator exists in the array collection on the right of the operator. <code>foreach</code> The foreach statement can be applied to an array to iterate over the array elements."},{"location":"Collections/Arrays/#array-methods","title":"Array Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the arrays. int <code>sum()</code> Returns the sum of all elements currently stored in the array. list&lt;data_type&gt; <code>to_list()</code> Returns all elements in a <code>list</code>-type. set&lt;data_type&gt; <code>to_set()</code>: Returns all elements in a <code>set</code>-type."},{"location":"Collections/Arrays/#index","title":"Index operator <code>[]</code>","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\nint intVal = intArray[2];   //  intVal: 0 -&gt; 3\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\nint intVal = intArray[2];   //  intVal: 0 -&gt; 3\n</code></pre> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Collections/Arrays/#assignment","title":"Assignment operator <code>=</code>","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\nintArray[2] = 4;            //  intArray: {1, 2, 3} -&gt; {1, 2, 4}\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\nintArray[2] = 4;            //  intArray: {1, 2, 3} -&gt; {1, 2, 4}\n</code></pre> Note <p>Operator that do not modify contents can be used within exec block or native functions.</p>"},{"location":"Collections/Arrays/#equality","title":"Equality operator <code>==</code>","text":"TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0  = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1  = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 == intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0 == intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0 == stringArray) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 0 (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> <pre><code>int    intArray_0  [2] = {  1 ,  2      };\nint    intArray_1  [3] = {  1 ,  2 ,  3 };\nstring stringArray [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 == intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0 == intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0 == stringArray) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 0 (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Collections/Arrays/#inequality","title":"Inequality operator <code>!=</code>","text":"TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0  = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1  = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 != intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0 != intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 1 (3)\nif (intArray_0 != stringArray) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 1 (4)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> <pre><code>int    intArray_0  [2] = {  1 ,  2      };\nint    intArray_1  [3] = {  1 ,  2 ,  3 };\nstring stringArray [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 != intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0 != intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 1 (2)\nif (intArray_0 != stringArray) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 1 (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Collections/Arrays/#in","title":"Set membership operator <code>in</code>","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nbit bitVal_0, bitVal_1;\nif (1 in intArray) bitVal_0 = 1;                //  bitval_0: 0 -&gt; 1\nif (0 in intArray) bitVal_1 = 1;                //  bitVal_1: 0 -&gt; 0\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nbit bitVal_0, bitVal_1;\nif (1 in intArray) bitVal_0 = 1;                //  bitval_0: 0 -&gt; 1\nif (0 in intArray) bitVal_1 = 1;                //  bitVal_1: 0 -&gt; 0\n</code></pre> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Collections/Arrays/#foreach","title":"<code>foreach</code> statement","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nforeach (intArray[i]) {\n    intArray[i] = intArray[i] + 1;  //  intArray: {1, 2, 3} -&gt; {2, 3, 4}\n}\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nforeach (intArray[i]) {\n    intArray[i] = intArray[i] + 1;  //  intArray: {1, 2, 3} -&gt; {2, 3, 4}\n}\n</code></pre> Note <p>Operator that do not modify contents can be used within activity, constraint, native exec code or covergroup.</p>"},{"location":"Collections/Arrays/#size","title":"function int <code>size()</code>","text":"TemplateSquare <pre><code>array&lt;int, 2&gt; intArray;\nint intVal = intArray.size();  //  intVal: 0 -&gt; 2\n</code></pre> <pre><code>int intArray [2];\nint intVal = intArray.size();  //  intVal: 0 -&gt; 2\n</code></pre> Note <p>Considered as a constant expression.</p>"},{"location":"Collections/Arrays/#sum","title":"function int <code>sum()</code>","text":"TemplateSquare <pre><code>array&lt;int    , 2&gt; intArray    = {  1   ,  2    };\narray&lt;bit [2], 2&gt; bitArray    = { 2'b01, 2'b10 };\narray&lt;string , 2&gt; stringArray = { \"1\"  , \"2\"   };\nint intVal_0 = intArray.sum()   ;  //  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;  //  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();  //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <pre><code>int     intArray    [2] = {  1   ,  2    };\nbit [2] bitArray    [2] = { 2'b01, 2'b10 };\nstring  stringArray [2] = { \"1\"  , \"2\"   };\nint intVal_0 = intArray.sum()   ;  //  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;  //  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();  //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> Note <p>Only can used on numeric data type (<code>int</code> or <code>bit</code>).</p> Usage: use <code>sum()</code> to constrain a random array TemplateSquare <pre><code>rand array&lt;int, 2&gt; intArray;\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;   //  intArray: {0, 0} -&gt; {2, 1}\n}\n</code></pre> <pre><code>rand int intArray [2];\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;   //  intArray: {0, 0} -&gt; {2, 1}\n}\n</code></pre>"},{"location":"Collections/Arrays/#to_list","title":"function list&lt;data_type&gt; <code>to_list()</code>","text":"TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\nlist&lt;int   &gt; intList    = intArray.to_list()   ;    //  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();    //  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\nlist&lt;int   &gt; intList    = intArray.to_list()   ;    //  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();    //  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre>"},{"location":"Collections/Arrays/#to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>","text":"TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\nset&lt;int   &gt; intSet    = intArray.to_set()   ;       //  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();       //  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\nset&lt;int   &gt; intSet    = intArray.to_set()   ;       //  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();       //  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre>"},{"location":"Collections/Lists/","title":"List","text":""},{"location":"Collections/Lists/#declarations","title":"Declarations","text":"<pre><code>list&lt;int     &gt; intList   ;  //  declare an integer list\nlist&lt;bit [8] &gt; byteList  ;  //  declare a byte list\nlist&lt;bool    &gt; boolList  ;  //  declare a bool list\nlist&lt;string  &gt; stringList;  //  declare a string list\nlist&lt;eSTR2NUM&gt; enumList  ;  //  declare an enum list (1)\nlist&lt;sSTR2NUM&gt; structList;  //  declare a struct list (2)\n</code></pre> <ol> <li> <p>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></p> </li> <li> <p>Assume defined struct type before <pre><code>struct sSTR2NUM {\n    string stringVal;\n    int intVal;\n};\n</code></pre></p> </li> </ol>"},{"location":"Collections/Lists/#declare-list-by-rand-keyword","title":"Declare list by <code>rand</code> keyword:","text":"<p> v2.1 <pre><code>rand list&lt;int    &gt; intList   ;\nrand list&lt;bit [8]&gt; byteList  ;\nrand list&lt;string &gt; stringList;\n</code></pre></p>"},{"location":"Collections/Lists/#list-operators","title":"List Operators","text":"Operator Description <code>[]</code> Used to access a specific element of a list. <code>=</code> Creates a copy of the <code>list</code>-type expression on the RHS and assigns it to the list on the LHS. <code>==</code> Evaluates to true if all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true if not all elements with corresponding indexes are equal. <code>in</code> It evaluates to true if the element specified on the left of the operator exists in the list collection on the right of the operator. <code>foreach</code> The foreach statement can be applied to a list to iterate over the list elements."},{"location":"Collections/Lists/#list-methods","title":"List Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the list. <code>clear()</code> Removes all elements. &lt;data_type&gt; <code>delete(int index)</code> Moves out element at the specified index. <code>insert(int index, data_type element)</code> Adds element at the specified index. &lt;data_type&gt; <code>pop_front()</code> Moves out first element. Same as <code>delete(0)</code>. <code>push_front(data_type element)</code> Adds element at beginning of list. Same as <code>insert(0, element)</code>. &lt;data_type&gt; <code>pop_back()</code> Moves out last element. Same as <code>delete(size()-1)</code>. <code>push_back(data_typeelement)</code> Adds element at end of list. Same as <code>insert(size(), element)</code>. set&lt;data_type&gt; <code>to_set()</code> Returns all elements to a <code>set</code>-type. <code>shuffle()</code> v2.1 Randomizes orders of elements."},{"location":"Collections/Lists/#index","title":"Index operator <code>[]</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList[1];    //  intVal: 0 -&gt; 2\n</code></pre>"},{"location":"Collections/Lists/#assignment","title":"Assignment operator <code>=</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList[0] = 4;             //  intVal: {1, 2, 3} -&gt; {4, 2, 3}\n</code></pre>"},{"location":"Collections/Lists/#equality","title":"Equality operator <code>==</code>","text":"<pre><code>list&lt;int   &gt; intList_0  = { 1 ,  2 ,  3      };\nlist&lt;int   &gt; intList_1  = { 1 ,  2 ,  3 ,  4 };\nlist&lt;string&gt; stringList = {\"1\", \"2\", \"3\"};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intList_0 == intList_0 ) bitVal_0 = 1;  //  bitVal_0: 0 -&gt; 1; (1)\nif (intList_0 == intList_1 ) bitVal_1 = 1;  //  bitVal_1: 0 -&gt; 0; (2)\nif (intList_0 == stringList) bitVal_2 = 1;  //  bitVal_2: 0 -&gt; 0; (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol>"},{"location":"Collections/Lists/#inequality","title":"Inequality operator <code>!=</code>","text":"<pre><code>list&lt;int   &gt; intList_0  = { 1 ,  2 ,  3      };\nlist&lt;int   &gt; intList_1  = { 1 ,  2 ,  3 ,  4 };\nlist&lt;string&gt; stringList = {\"1\", \"2\", \"3\"};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intList_0 != intList_0 ) bitVal_0 = 1;  //  bitVal_0: 0 -&gt; 0; (1)\nif (intList_0 != intList_1 ) bitVal_1 = 1;  //  bitVal_1: 0 -&gt; 1; (2)\nif (intList_0 != stringList) bitVal_2 = 1;  //  bitVal_2: 0 -&gt; 1; (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol>"},{"location":"Collections/Lists/#in","title":"Set membership operator <code>in</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nbit bitVal_0, bitVal_1;\nif ( 1 in intList) bitVal_0 = 1;            //  bitVal_0: 0 -&gt; 1;\nif ( 0 in intList) bitVal_1 = 1;            //  bitVal_1: 0 -&gt; 0;\n</code></pre> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Collections/Lists/#foreach","title":"<code>foreach</code> statement","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nforeach (intList[i]) {\n    intList[i] = intList[i] + 1;            //  intList: {1, 2, 3} -&gt; {2, 3, 4}\n}\n</code></pre> Note <p>Operator can be used within activity, constraint, or native exec code.</p>"},{"location":"Collections/Lists/#size","title":"function int <code>size()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList.size();        //  intVal: 0 -&gt; 3\n</code></pre>"},{"location":"Collections/Lists/#clear","title":"function void <code>clear()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList.clear();                    //  intList: {1, 2, 3} -&gt; {}\n</code></pre>"},{"location":"Collections/Lists/#delete","title":"function &lt;data_type&gt; <code>delete(index)</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList.delete(1);     //  intVal: 0 -&gt; 2; intList: {1, 2, 3} -&gt; {1, 3}\n</code></pre>"},{"location":"Collections/Lists/#insert","title":"function void <code>insert(index, element)</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList.insert(1, 6);               //  intList: {1, 2, 3} -&gt; {1, 6, 2, 3}\n</code></pre>"},{"location":"Collections/Lists/#pop_front","title":"function &lt;data_type&gt; <code>pop_front()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList.pop_front();   //  intVal: 0 -&gt; 1; intList: {1, 2, 3} -&gt; {2, 3}\n</code></pre>"},{"location":"Collections/Lists/#push_front","title":"function void <code>push_front(element)</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList.push_front(4);              //  intList: {1, 2, 3} -&gt; {4, 1, 2, 3}\n</code></pre>"},{"location":"Collections/Lists/#pop_back","title":"function &lt;data_type&gt; <code>pop_back()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList.pop_back();    //  intVal: 0 -&gt; 3; intList: {1, 2, 3} -&gt; {1, 2}\n</code></pre>"},{"location":"Collections/Lists/#push_back","title":"function void <code>push_back(element)</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList.push_back(4);               //  intList: {1, 2, 3} -&gt; {1, 2, 3, 4}\n</code></pre>"},{"location":"Collections/Lists/#to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 1};\nset&lt;int&gt; intSet = intList.to_set(); //  intSet: {} -&gt; {1, 2}\n</code></pre>"},{"location":"Collections/Lists/#shuffle","title":"function void <code>shuffle()</code>","text":"<p> v2.1 <pre><code>list&lt;int&gt; intList = {1, 2};\nintList.shuffle();                  //  intList: {1, 2} -&gt; {1, 2} or {2, 1}\n</code></pre></p>"},{"location":"Collections/Maps/","title":"Map","text":""},{"location":"Collections/Maps/#properties","title":"Properties","text":"<ul> <li>Unordered.</li> <li>Non-randomizable.</li> <li>Elements can be added or removed within <code>exec</code> blocks.</li> <li>Key and element can be any scalar or aggregate of scalars.</li> <li>Keys must be unique.</li> </ul>"},{"location":"Collections/Maps/#declarations","title":"Declarations","text":"Without Initialization AssignmentWith Initialization Assignment <pre><code>map&lt;bit [4] , int    &gt; nibble2int  ;    //  nibble2int  : {}\nmap&lt;int     , bool   &gt; int2bool    ;    //  int2bool    : {}\nmap&lt;bool    , string &gt; bool2string ;    //  bool2string : {}\nmap&lt;string  , float32&gt; string2float;    //  string2float: {}\nmap&lt;float32 , int    &gt; float2int   ;    //  float2int   : {}\nmap&lt;eSTR2NUM, int    &gt; enum2int    ;    //  enum2int    : {} (1)\n</code></pre> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol> <pre><code>map&lt;bit [4] , int    &gt; nibble2int   = {4'b1110:3      , 4'b0110:2     };\nmap&lt;int     , bool   &gt; int2bool     = {      4:true   ,       5:false };\nmap&lt;bool    , string &gt; bool2string  = {  false:\"FALSE\",    true:\"TRUE\"};\nmap&lt;string  , float32&gt; string2float = {  \"2.1\":2.1    ,   \"2.2\":2.2   };\nmap&lt;float32 , int    &gt; float2int    = {    2.4:2      ,     2.6:3     };\nmap&lt;eSTR2NUM, int    &gt; enum2int     = {    ONE:1      ,     TWO:2     }; // (1)!\n</code></pre> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Maps/#map-operators","title":"Map Operators","text":"Operator Description <code>[]</code> Used to access a specific element of a map. <code>=</code> Creates a copy of the <code>map</code>-type expression on the RHS and assigns it to the map on the LHS. <code>==</code> Evaluates to true if all elements with corresponding keys are equal. <code>!=</code> Evaluates to true if not all elements with corresponding keys are equal. <code>foreach</code> The foreach statement can be applied to a map to iterate over the map elements."},{"location":"Collections/Maps/#map-methods","title":"Map Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the map. <code>clear()</code> Removes all elements. &lt;data_type&gt; <code>delete(key)</code> Moves out element with the specified key. <code>insert(key, element)</code> Adds or replace element with the specified key. set&lt;data_type&gt; <code>keys()</code> Returns all keys in a <code>set</code>-type. list&lt;data_type&gt; <code>values()</code> Returns all elements in a <code>list</code>-type."},{"location":"Collections/Maps/#index","title":"Index operator <code>[]</code>","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\nint intVal = string2int[\"2\"];   //  intVal: 0 -&gt; 2;\nint intVal = string2int[\"3\"];   //  ILLEGAL (1)\n</code></pre> <ol> <li>Key <code>\"3\"</code> not exist.</li> </ol>"},{"location":"Collections/Maps/#assignment","title":"Assignment operator <code>=</code>","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\nstring2int[\"1\"] = 0;    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"1\":0, \"2\":2}\nstring2int[\"3\"] = 3;    //  string2int: {\"1\":0, \"2\":2} -&gt; {\"1\":0, \"2\":2, \"3\":3}\n</code></pre>"},{"location":"Collections/Maps/#equality","title":"Equality operator <code>==</code>","text":"<pre><code>map&lt;string, int   &gt; map_0 = {\"1\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_1 = {\"1\":0  , \"2\":2  };\nmap&lt;string, int   &gt; map_2 = {\"0\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_3 = {\"2\":2  , \"1\":1  };\nmap&lt;string, int   &gt; map_4 = {\"1\":1           };\nmap&lt;int   , string&gt; map_5 = {  1:\"1\",   2:\"2\"};\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3, bitVal_4, bitVal_5;\nif (map_0 == map_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 1 (1)\nif (map_0 == map_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 0 (2)\nif (map_0 == map_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 0 (3)\nif (map_0 == map_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 1 (4)\nif (map_0 == map_4) bitVal_4 = 1;   //  bitVal_4: 0 -&gt; 0 (5)\nif (map_0 == map_5) bitVal_5 = 1;   //  bitVal_5: 0 -&gt; 0 (6)\n</code></pre> <ol> <li>Equalize size, keys, elements.</li> <li>Inequalize element.</li> <li>Inequalize key.</li> <li>Equalize size, keys, elements.</li> <li>Inequalize size.</li> <li>Inequalize keys, elements.</li> </ol>"},{"location":"Collections/Maps/#inequality","title":"Inequality operator <code>==</code>","text":"<pre><code>map&lt;string, int   &gt; map_0 = {\"1\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_1 = {\"1\":0  , \"2\":2  };\nmap&lt;string, int   &gt; map_2 = {\"0\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_3 = {\"2\":2  , \"1\":1  };\nmap&lt;string, int   &gt; map_4 = {\"1\":1           };\nmap&lt;int   , string&gt; map_5 = {  1:\"1\",   2:\"2\"};\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3, bitVal_4, bitVal_5;\nif (map_0 != map_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 0 (1)\nif (map_0 != map_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 1 (2)\nif (map_0 != map_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 1 (3)\nif (map_0 != map_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 0 (4)\nif (map_0 != map_4) bitVal_4 = 1;   //  bitVal_4: 0 -&gt; 1 (5)\nif (map_0 != map_5) bitVal_5 = 1;   //  bitVal_5: 0 -&gt; 1 (6)\n</code></pre> <ol> <li>Equalize size, keys, elements.</li> <li>Inequalize element.</li> <li>Inequalize key.</li> <li>Equalize size, keys, elements.</li> <li>Inequalize size.</li> <li>Inequalize keys, elements.</li> </ol>"},{"location":"Collections/Maps/#foreach","title":"<code>foreach</code> statement","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nforeach (string2int[i]) {\n    string2int[i] = string2int[i] + 1;  //  string2int: {\"1\":1, \"2\":2} -&gt; {\"1\":2, \"2\":3}\n}\n</code></pre> Note <p>Operator can be used within activity, constraint, or native exec code.</p>"},{"location":"Collections/Maps/#size","title":"function int <code>size()</code>","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\nint intVal = string2int.size(); //  intVal: 0 -&gt; 2\n</code></pre>"},{"location":"Collections/Maps/#clear","title":"function void <code>clear()</code>","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\nstring2int.clear(); //  string2int: {\"1\":1, \"2\":2} -&gt; {}\n</code></pre>"},{"location":"Collections/Maps/#delete","title":"function &lt;data_type&gt; <code>delete(data_type key)</code>","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\nmap.delete(\"1\");    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"2\":2}\nmap.delete(\"3\");    //  ILLEGAL (1)\n</code></pre> <ol> <li>Key <code>\"3\"</code> not exist.</li> </ol>"},{"location":"Collections/Maps/#insert","title":"function void <code>insert(data_type key, data_type element)</code>","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\nstring2int.insert(\"1\", 0  );    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"1\":0, \"2\":2}\nstring2int.insert(\"3\", 3  );    //  string2int: {\"1\":0, \"2\":2} -&gt; {\"1\":0, \"2\":2, \"3\":3}\nstring2int.insert(\"4\", 4.0);    //  ILLEGAL (1)\nstring2int.insert(5  , 5  );    //  ILLEGAL (2)\n</code></pre> <ol> <li>Data type of element is not same.</li> <li>Data type of key is not same.</li> </ol>"},{"location":"Collections/Maps/#keys","title":"function set&lt;data_type&gt; <code>keys()</code>","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2, \"2.5\":2};\n\nset&lt;string&gt; stringSet = string2int.keys();  //  stringSet: {} -&gt; {\"1\", \"2\", \"2.5\"}\n</code></pre>"},{"location":"Collections/Maps/#values","title":"function list&lt;data_type&gt; <code>values()</code>","text":"<pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2, \"2.5\":2};\n\nlist&lt;int&gt; intList = string2int.values();    //  intList: {} -&gt; {1, 2, 2}\n</code></pre>"},{"location":"Collections/Sets/","title":"Set","text":""},{"location":"Collections/Sets/#properties","title":"Properties","text":"<ul> <li>Unordered.</li> <li>Non-randomizable.</li> <li>Element can be any scalar or aggregate of scalars.</li> <li>Elements must be unique.</li> </ul>"},{"location":"Collections/Sets/#declarations","title":"Declarations","text":"Without Initialization AssignmentWith Initialization Assignment <pre><code>set&lt;bit [4] &gt; nibbleSet;    //  nibbleSet: {}\nset&lt;int     &gt; intSet   ;    //  intSet   : {}\nset&lt;bool    &gt; boolSet  ;    //  boolSet  : {}\nset&lt;string  &gt; stringSet;    //  stringSet: {}\nset&lt;float32 &gt; floatSet ;    //  floatSet : {}\nset&lt;eSTR2NUM&gt; enumSet  ;    //  enumSet  : {} (1)\n</code></pre> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol> <pre><code>set&lt;bit [4] &gt; nibbleSet = {4'b0001, 4'b0010};\nset&lt;int     &gt; intSet    = {      1, 2      };\nset&lt;bool    &gt; boolSet   = {  false, true   };\nset&lt;string  &gt; stringSet = {    \"1\", \"2\"    };\nset&lt;float32 &gt; floatSet  = {    1.0, 2.0    };\nset&lt;eSTR2NUM&gt; enumSet   = {    ONE, TWO    };   // (1)!\n</code></pre> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Sets/#set-operators","title":"Set Operators","text":"Operator Description <code>=</code> Creates a copy of the set-type expression on the RHS and assigns it to the set on the LHS. <code>==</code> Evaluates to true if all elements are equal. <code>!=</code> Evaluates to true if not all elements are equal. <code>in</code> It evaluates to true if the element specified on the left of the operator exists in the set collection on the right of the operator. <code>foreach</code> The foreach statement can be applied to a set to iterate over the set elements."},{"location":"Collections/Sets/#set-methods","title":"Set Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the set. <code>clear()</code> Removes all elements. <code>delete(data_type element)</code> Removes the specified element. <code>insert(data_type element)</code> Adds the specified element. list&lt;data_type&gt; <code>to_list()</code> Returns all elements in a <code>list</code>-type."},{"location":"Collections/Sets/#assignment","title":"Assignment operator <code>=</code>","text":"<pre><code>set&lt;int&gt; intSet;\n\nintSet = {1, 2};    //  intSet: {}     -&gt; {1, 2}\nintSet = {3, 3, 4}; //  intSet: {1, 2} -&gt; {3, 4} (1)\n</code></pre> <ol> <li>Same element will appear only once.</li> </ol>"},{"location":"Collections/Sets/#equality","title":"Equality operator <code>==</code>","text":"<pre><code>set&lt;int   &gt; set_0 = { 1 ,  2      };\nset&lt;int   &gt; set_1 = { 2 ,  1      };\nset&lt;int   &gt; set_2 = { 1 ,  2 ,  3 };\nset&lt;string&gt; set_3 = {\"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (set_0 == set_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 1 (1)\nif (set_0 == set_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 1 (2)\nif (set_0 == set_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 0 (3)\nif (set_0 == set_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 0 (4)\n</code></pre> <ol> <li>Equalize size, type, and all elements.</li> <li>Equalize size, type, and all elements in different order.</li> <li>Inequalize size.</li> <li>Inequalize type.</li> </ol>"},{"location":"Collections/Sets/#inequality","title":"Inequality operator <code>!=</code>","text":"<pre><code>set&lt;int   &gt; set_0 = { 1 ,  2      };\nset&lt;int   &gt; set_1 = { 2 ,  1      };\nset&lt;int   &gt; set_2 = { 1 ,  2 ,  3 };\nset&lt;string&gt; set_3 = {\"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (set_0 != set_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 0 (1)\nif (set_0 != set_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 0 (2)\nif (set_0 != set_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 1 (3)\nif (set_0 != set_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 1 (4)\n</code></pre> <ol> <li>Equalize size, type, and all elements.</li> <li>Equalize size, type, and all elements in different order.</li> <li>Inequalize size.</li> <li>Inequalize type.</li> </ol>"},{"location":"Collections/Sets/#in","title":"Set membership operator <code>in</code>","text":"<pre><code>set&lt;int&gt; intSet = {1, 2};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (1   in intSet) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1\nif (3   in intSet) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intSet) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 0\n</code></pre>"},{"location":"Collections/Sets/#foreach","title":"<code>foreach</code> statement","text":"<pre><code>set&lt;int&gt; intSet = {1, 2};\n\nint sum = 0;\nforeach (i:intSet) {\n    sum += i;   //  sum: 0 -&gt; 3\n}\n</code></pre> Warning <p>For <code>set</code>-type, index variable of <code>foreach</code> statament should NOT be used to specify <code>set</code> elements. <pre><code>foreach (intSet[i]) {}  //  ILLEGAL\n</code></pre></p>"},{"location":"Collections/Sets/#size","title":"function int <code>size()</code>","text":"<pre><code>set&lt;int&gt; intSet = {1, 2};\n\nint intVal = intSet.size(); //  intVal: 0 -&gt; 2\n</code></pre>"},{"location":"Collections/Sets/#clear","title":"function void <code>clear()</code>","text":"<pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.clear(); // intSet: {1, 2} -&gt; {}\n</code></pre>"},{"location":"Collections/Sets/#delete","title":"function void <code>delete(data_type element)</code>","text":"<pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.delete( 2 ); //  intSet: {1, 2} -&gt; {1}\nintSet.delete( 3 ); //  ILLEGAL (1)\nintSet.delete(\"1\"); //  ILLEGAL (2)\n</code></pre> <ol> <li>The element is not exist in the set.</li> <li>Data type of the element is not same as the set.</li> </ol>"},{"location":"Collections/Sets/#insert","title":"function void <code>insert(data_type element)</code>","text":"<pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.insert( 3 ); //  intSet: {1, 2}    -&gt; {1, 2, 3}\nintSet.insert( 2 ); //  intSet: {1, 2, 3} -&gt; {1, 2, 3}\nintSet.insert(\"4\"); //  ILLEGAL (1)\n</code></pre> <ol> <li>Data type of the element is not same as the set.</li> </ol>"},{"location":"Collections/Sets/#to_list","title":"function list&lt;data_type&gt; <code>to_list()</code>","text":"<pre><code>set&lt;int&gt; intSet = {1, 2};\n\nlist&lt;int&gt; intList = intSet.to_list();   //  intList: {} -&gt; {1, 2}\n</code></pre>"},{"location":"DataTypes/","title":"Data Types","text":""},{"location":"DataTypes/#datatypes_scalar","title":"Scalar Type","text":"Scalar Type Randomizable <code>bit</code> <code>int</code> <code>bool</code> <code>enum</code> <code>string</code> <code>float32</code> v2.1 <code>float64</code> v2.1 <code>chandle</code>"},{"location":"DataTypes/#datatypes_aggregate","title":"Aggregate","text":"Aggregate Type Randomizable <code>array</code>  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code> <code>list</code>  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code> v2.1 <code>map</code> <code>set</code> <code>struct</code>  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code> <p>Aggregate may be nested.</p>"},{"location":"DataTypes/#datatypes_non_aggregate","title":"Non-aggregate","text":"<ul> <li><code>component</code></li> <li><code>action</code></li> <li><code>buffer</code></li> <li><code>stream</code></li> <li><code>state</code></li> <li><code>resource</code></li> </ul>"},{"location":"DataTypes/IntegerTypes/","title":"Integer Types","text":""},{"location":"DataTypes/IntegerTypes/#datatypes_integertypes_bit","title":"Bit","text":"<p><code>bit</code> is a integer data type with default properties: unsigned, 1-bit width, {0, 1} domain.</p>"},{"location":"DataTypes/IntegerTypes/#declare-a-bit","title":"Declare a bit","text":"<pre><code>bit singleBit;\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#declare-8-bits-wide-bit-type","title":"Declare 8-bits wide <code>bit</code> type","text":"<p>Possible values specified by bit width are {0..(2<sup>width</sup>-1)}</p> single bounddual bound <pre><code>bit [8] singleByte;     //  possible values: {0..127};\n</code></pre> <pre><code>bit [7:0] singleByte;   //  possible values: {0..127};\n</code></pre> <p>lower bound must be <code>0</code></p> <p>dual bounds may be removed in future version</p>"},{"location":"DataTypes/IntegerTypes/#declared-with-specified-value-domain","title":"Declared with specified value domain","text":"<p>Values of variable are within intersection of possible values by width and value domain. <pre><code>bit [8] in [0, 1, 5]             singleByte;    //  value domain: {0, 1, 5}\nbit [8] in [..2]                 singleByte;    //  value domain: {0, 1, 2}\nbit [8] in [6..8]                singleByte;    //  value domain: {6, 7, 8}\nbit [8] in [254..]               singleByte;    //  value domain: {254, 255}\nbit [8] in [5, ..2, 6..8, 254..] singleByte;    //  value domain: {0, 1, 2, 5, 6, 7, 8, 254, 255}\n</code></pre></p> <p>Tip</p> <p>Specify value domain is useful for random variable. Following examples are equalize:</p> value domain within declarationvalue domain within <code>constraint</code> <pre><code>rand bit [8] in [5, ..2, 6..8, 253..] singleByte;\n</code></pre> <pre><code>rand bit [8] singleByte;\nconstraint {\n    singleByte in [5, ..2, 6..8, 253..];\n}\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#datatypes_integertypes_integer","title":"Integer","text":"<p><code>int</code> is a integer data type with default properties: signed, 32-bits width, {-2<sup>31</sup>..(2<sup>31</sup>-1)} domain.</p>"},{"location":"DataTypes/IntegerTypes/#declare-an-integer","title":"Declare an integer:","text":"<pre><code>int int32;\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#declare-8-bits-wide-int-type","title":"Declare 8-bits wide <code>int</code> type","text":"<p>Possible values specified by bit width are {-2<sup>width-1</sup>..(2<sup>width-1</sup>-1)}</p> single bounddual bound <pre><code>int [8] int8;       //  possible values: {-128..127}\n</code></pre> <pre><code>int [7:0] int8;     //  possible values: {-128..127}\n</code></pre> <p>lower bound must be <code>0</code></p> <p>dual bounds may be removed in future version</p>"},{"location":"DataTypes/IntegerTypes/#declared-with-specified-value-domain_1","title":"Declared with specified value domain","text":"<p>Values of variable are within intersection of possible values by width and value domain. <pre><code>int [8] in [0, 1, 5]                  int8; //  value domain: {0, 1, 5}\nint [8] in [..(-127)]                 int8; //  value domain: {-128, -127}\nint [8] in [6..8]                     int8; //  value domain: {6, 7, 8}\nint [8] in [126..]                    int8; //  value domain: {126, 127}\nint [8] in [5, ..(-127), 6..8, 253..] int8; //  value domain: {-128, -127, 5, 6, 7, 8, 126, 127}\n</code></pre></p> <p>Tip</p> <p>Specify value domain is useful for random variable. Following examples are equalize:</p> value domain within declarationvalue domain within <code>constraint</code> <pre><code>rand int [8] in [5, ..(-127), 6..8, 253..] int8;\n</code></pre> <pre><code>rand int [8] int8;\nconstraint {\n    int8 in [5, ..(-127), 6..8, 253..];\n}\n</code></pre>"},{"location":"Operator/","title":"Operators and Expressions","text":""},{"location":"Operator/#assignment-operators","title":"Assignment Operators","text":"<p>Work in Progress</p>"},{"location":"Operator/#expression-operators-and-data-types","title":"Expression operators and data types","text":"Operator token Operator name Operator data types Result data type <code>?:</code> Conditional operator Any plain-data type or reference type Same as operands <code>-</code> Unary arithmetic negation operator Numeric Same as operand <code>~</code> Unary bitwise negation operator Numeric Same as operand <code>!</code> Unary Boolean negation operator Boolean Boolean <code>&amp; | ^</code> Unary bitwise reduction operators Numeric 1-bit <code>+ - * / % **</code> Binary arithmetic operators Numeric 1-bit <code>&amp; | ^</code> Binary bitwise operators Numeric 1-bit <code>&gt;&gt; &lt;&lt;</code> Binary shift operators Numeric Same as left operand <code>&amp;&amp; ||</code> Binary Boolean logical operators Boolean Same as operands <code>&lt; &lt;= &gt; &gt;=</code> Binary relational operators Numeric Boolean <code>== !=</code> Binary logical equality operators Any plain-data type or reference type Boolean <code>cast</code> Data type conversion operator Numeric, Boolean, enum Casting type <code>in</code> Binary set membership operator Any plain-data type Boolean <code>[expression]</code> Index operator Array, list, map Same as element of collection <code>[expression]</code> Bit-select operators Numeric Numeric <code>[expression:expression]</code> Part-select operator Numeric Numeric"},{"location":"Operator/#operator-precedence-and-associativity","title":"Operator precedence and associativity","text":"Operator Associativity Precesence <code>()</code> <code>[]</code> Left 1 (Highest) <code>cast</code> Right 2 <code>-</code> <code>!</code> <code>~</code> <code>&amp;</code> <code>|</code> <code>^</code> (unary) 2 <code>**</code> Left 3 <code>*</code> <code>/</code> <code>%</code> Left 4 <code>+</code> <code>-</code> (binary) Left 5 <code>&lt;&lt;</code> <code>&gt;&gt;</code> Left 6 <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>in</code> Left 7 <code>==</code> <code>!=</code> Left 8 <code>&amp;</code> (binary) Left 9 <code>^</code> (binary) Left 10 <code>|</code> (binary) Left 11 <code>&amp;&amp;</code> Left 12 <code>||</code> Left 13 <code>?:</code> (conditional operator) Right 14 (Lowest)"},{"location":"Operator/BinaryBitwise/","title":"Binary Bitwise Operators","text":"<p>PSS supports 3 basic bitwise operators: 1. Bitwise AND <code>&amp;</code> 2. Bitwise OR <code>|</code> 3. Bitwise XOR <code>^</code></p>"},{"location":"Operator/BinaryBitwise/#constant-op-constant","title":"CONSTANT op CONSTANT","text":"<pre><code>bit [8] byteAND = 8'b0110_1001 &amp; 8'b0000_1111;  //  byteAND: 0 -&gt; 8'b0000_1001\nbit [8] byteOR  = 8'b0110_1001 | 8'b0000_1111;  //  byteOR : 0 -&gt; 8'b0110_1111\nbit [8] byteXOR = 8'b0110_1001 ^ 8'b0000_1111;  //  byteXOR: 0 -&gt; 8'b0110_0110\n</code></pre>"},{"location":"Operator/Expressions/","title":"Primary Expressions","text":""},{"location":"Operator/Expressions/#bit-selects-and-part-selects","title":"Bit-selects and part-selects","text":""},{"location":"Operator/Expressions/#primary_expressions_bit-selects","title":"Bit-selects","text":"<p>Get a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nbit bitVal = nibbleVal[1];      ///&lt;  bitVal: 0 -&gt; 1\n</code></pre></p> <p>Assign a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[1] = 0;               ///&lt;  nibbleVal: 0b0011 -&gt; 0b0001\n</code></pre></p> <p>Assign a bit of variable by a non-zero integer: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[2] = 2'b10;           ///&lt;  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> <p>Operate a bit of variable by another bit: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[2] |= nibbleVal[1];   ///&lt;  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\nbit bitVal = nibbleVal[10];     ///&lt;  ILLEGAL (1)\nnibbleVal[10] = 1;              ///&lt;  ILLEGAL (2)\nnibbleVal[-1] = 1;              ///&lt;  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>index must be inbound of bit-width.</li> <li>index must be inbound of bit-width.</li> <li>index shall be any integer greater than zero.</li> </ol>"},{"location":"Operator/Expressions/#primary_expressions_part-selects","title":"Part-selects","text":"<p>Get 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nbit [2] bitVal = nibbleVal[1:0];    ///&lt;  bitVal: 0b00 -&gt; 0b11\nbit [2] bitVal = nibbleVal[0:1];    ///&lt;  ILLEGAL SYNTAX (1)\n</code></pre></p> <ol> <li>LSB of range shall be smaller than MSB.</li> </ol> <p>Assign 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[1:0] = 2'b00;             ///&lt;  nibbleVal: 0b0011 -&gt; 0b0000\n</code></pre></p> <p>Operate 2 bits of variable by another 2 bits: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[3:2] |= nibbleVal[1:0];   ///&lt;  nibbleVal: 0b0011 -&gt; 0b1111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\nbit [2] bitVal = nibbleVal[4:3];    ///&lt;  ILLEGAL (1)\nnibbleVal[4:3] = 2'b01;             ///&lt;  ILLEGAL (2)\nnibbleVal[0:-1] = 2'b01;            ///&lt;  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>MSB/LSB of range must be inbound of bit-width.</li> <li>MSB/LSB of range must be inbound of bit-width.</li> <li>MSB/LSB of range shall be any integer greater than zero.</li> </ol>"},{"location":"Operator/Expressions/#primary_expressions_indexing","title":"Selecting an element from a collection (indexing)","text":"<p>Get an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[0]  ;  ///&lt;  nibbleArrayVal: 0 -&gt; 0b1100\nbit [4] nibbleListVal  = nibbleList[1]   ;  ///&lt;  nibbleListVal : 0 -&gt; 0b0110\nbit [4] nibbleMapVal   = nibbleMap[\"ONE\"];  ///&lt;  nibbleMapVal  : 0 -&gt; 0b1100\n</code></pre></p> <p>Assign an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nnibbleArray[0]   = 4'b0011;  ///&lt;  nibbleArray[0]  : 0b1100 -&gt; 0b0011\nnibbleList[0]    = 4'b0011;  ///&lt;  nibbleList[0]   : 0b1100 -&gt; 0b0011\nnibbleMap[\"ONE\"] = 4'b0001;  ///&lt;  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b0001\nnibbleMap[\"TWO\"] = 4'b0110;  ///&lt;  nibbleMap[\"TWO\"]: no_exist -&gt; 0b0110 (1)\n</code></pre></p> <ol> <li><code>map</code> will add the element if no existed.</li> </ol> <p>Operate an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100,        4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100,        4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100, \"TWO\": 4'b0110};\n\nnibbleArray[0]   |= nibbleArray[1]  ;  ///&lt;  nibbleArray[0]  : 0b1100 -&gt; 0b1110\nnibbleList[0]    |= nibbleList[1]   ;  ///&lt;  nibbleList[0]   : 0b1100 -&gt; 0b1110\nnibbleMap[\"ONE\"] |= nibbleMap[\"TWO\"];  ///&lt;  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b1110\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[2]  ;  ///&lt;  ILLEGAL (1)\nbit [4] nibbleListVal  = nibbleList[2]   ;  ///&lt;  ILLEGAL (2)\nbit [4] nibbleMapVal   = nibbleMap[\"TWO\"];  ///&lt;  ILLEGAL (3)\n</code></pre> <ol> <li>index must be inbound of size.</li> <li>index must be inbound of size.</li> <li>The element must be exist in the <code>map</code>.</li> </ol>"},{"location":"Operator/Expressions/#usage","title":"Usage","text":"Access bit of an array <pre><code>array&lt;bit [4], 2&gt; nibbleArray = {4'b1100, 4'b0110};\n\nbit bitOnArray_0_2 = nibbleArray[0][2]; ///&lt;  bitOnArray_0_2: 0 -&gt; 1\nnibbleArray[1][0] = 1;                  ///&lt;  nibbleArray[1]: 0b0110 -&gt; 0b0111\n</code></pre>"},{"location":"Traversal/","title":"Traversal","text":""},{"location":"Traversal/#traversal-context","title":"Traversal Context","text":"Context Semantics <code>parallel</code> All array elements are scheduled for traversal in parallel. <code>schedule</code> All array elements are scheduled for traversal independently. <code>select</code> One array element is randomly selected and traversed. <code>sequence</code> All array elements are scheduled for traversal in sequence from <code>0</code> to <code>N-1</code>."},{"location":"Traversal/#traversal_parallel","title":"<code>parallel</code>","text":"<p>Work in Progress</p>"},{"location":"Traversal/#traversal_schedule","title":"<code>schedule</code>","text":"<p>Both actions (i.e., sub with \"Hello\" and \"World\") in <code>schedule</code> block will be traversed in random order. <pre><code>action top {\n    activity {\n        schedule {\n            do sub with { str == \"Hello\"; };\n            do sub with { str == \"World\"; };\n        }\n    }\n}\n\naction sub {\n    rand string str;\n    exec body ASM = \"\"\"{{str}}\"\"\";\n}\n</code></pre></p> <p>There have two possible results:</p> \"Hello\" first\"World\" first <pre><code>Hello\nWorld\n</code></pre> <pre><code>World\nHello\n</code></pre>"},{"location":"Traversal/#traversal_select","title":"<code>select</code>","text":"<p>Only one action in <code>select</code> block will be chosen and traversed. <pre><code>action top {\n    activity {\n        select {\n            do sub with { str == \"Hello\"; };\n            do sub with { str == \"World\"; };\n        }\n    }\n}\n\naction sub {\n    rand string str;\n    exec body ASM = \"\"\"{{str}}\"\"\";\n}\n</code></pre></p> <p>There have two possible results:</p> \"Hello\" chosen\"World\" chosen <pre><code>Hello\n</code></pre> <pre><code>World\n</code></pre>"},{"location":"Traversal/#traversal_sequence","title":"<code>sequence</code>","text":"<p>Work in Progress</p>"}]}