{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portable Test and Stimulus Standard (PSS) CookBook","text":"<p>In this document, we summarize the LRM of PSS, and give you extra examples and tips.</p>"},{"location":"#reference","title":"Reference","text":"<ul> <li>LRM: PSS 2.0 Language Reference Manual</li> <li>LRM: PSS 2.1 Language Reference Manual</li> <li>AndesTech PSS Generator: PSSGen</li> </ul>"},{"location":"Array/","title":"Array","text":""},{"location":"Array/#declarations","title":"Declarations","text":"<p>Array has 2 types of declare syntaxes: <code>Template</code>, <code>Square</code>.</p> TemplateSquare <pre><code>array&lt;int    , 3&gt; intArray   ;  //  declare integer array with 3 elements\narray&lt;bit [8], 3&gt; byteArray  ;  //  declare byte array with 3 elements\narray&lt;string , 3&gt; stringArray;  //  declare string array with 3 elements\narray&lt;array&lt;int, 3&gt;, 2&gt; nestedArray;    //  declare nested array with 3x2 integer elements\n</code></pre> <pre><code>int     intArray    [3];        //  declare integer array with 3 elements\nbit [8] byteArray   [3];        //  declare byte array with 3 elements\nstring  stringArray [3];        //  declare string array with 3 elements\n// (1)!\n</code></pre> <ol> <li><code>square</code> not support for declare nested array</li> </ol> <p>Declare array by <code>rand</code> keyword:</p> TemplateSquare <pre><code>rand array&lt;int, 3&gt; intArray;    //  declare integer array with 3 random elements\n</code></pre> <pre><code>rand int intArray [3];          //  declare integer array with 3 random elements\n</code></pre>"},{"location":"Array/#array-operators","title":"Array Operators","text":"Operator Description <code>[]</code> Used to access a specific element of an array. <code>=</code> Creates a copy of the array-type expression on the RHS and assigns it to the array on the LHS. <code>==</code> Evaluates to true if all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true if not all elements with corresponding indexes are equal. <code>in</code> It evaluates to true if the element specified on the left of the operator exists in the array collection on the right of the operator. <code>foreach</code> The foreach statement can be applied to an array to iterate over the array elements."},{"location":"Array/#array-methods","title":"Array Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the arrays. int <code>sum()</code> Returns the sum of all elements currently stored in the array. list&lt;data_type&gt; <code>to_list()</code> Returns a list containing the elements of the array. set&lt;data_type&gt; <code>to_set()</code>: Returns a set containing the elements of the array."},{"location":"Array/Methods/","title":"Array Methods","text":"<p>Methods that do not modify contents (e.g., <code>size()</code>, <code>sum()</code>, <code>to_list()</code>, <code>to_set()</code>) can be used within activity, constraint, or covergroup. </p>"},{"location":"Array/Methods/#array_methods_size","title":"function int <code>size()</code>","text":"TemplateSquare <pre><code>array&lt;int, 2&gt; intArray;\nint intVal = intArray.size();  //  intVal: 0 -&gt; 2\n</code></pre> <pre><code>int intArray [2];\nint intVal = intArray.size();  //  intVal: 0 -&gt; 2\n</code></pre> Note <p>Considered as a constant expression.</p>"},{"location":"Array/Methods/#array_methods_sum","title":"function int <code>sum()</code>","text":"TemplateSquare <pre><code>array&lt;int    , 2&gt; intArray    = {  1   ,  2    };\narray&lt;bit [2], 2&gt; bitArray    = { 2'b01, 2'b10 };\narray&lt;string , 2&gt; stringArray = { \"1\"  , \"2\"   };\nint intVal_0 = intArray.sum()   ;  //  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;  //  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();  //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <pre><code>int     intArray    [2] = {  1   ,  2    };\nbit [2] bitArray    [2] = { 2'b01, 2'b10 };\nstring  stringArray [2] = { \"1\"  , \"2\"   };\nint intVal_0 = intArray.sum()   ;  //  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;  //  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();  //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> Note <p>Only can used on numeric data type (<code>int</code> or <code>bit</code>).</p> Usage: use <code>sum()</code> to constrain a random array TemplateSquare <pre><code>rand array&lt;int, 2&gt; intArray;\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;   //  intArray: {0, 0} -&gt; {2, 1}\n}\n</code></pre> <pre><code>rand int intArray [2];\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;   //  intArray: {0, 0} -&gt; {2, 1}\n}\n</code></pre>"},{"location":"Array/Methods/#array_methods_to_list","title":"function list&lt;data_type&gt; <code>to_list()</code>","text":"TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\nlist&lt;int   &gt; intList    = intArray.to_list()   ;    //  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();    //  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\nlist&lt;int   &gt; intList    = intArray.to_list()   ;    //  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();    //  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre>"},{"location":"Array/Methods/#array_methods_to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>","text":"TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\nset&lt;int   &gt; intSet    = intArray.to_set()   ;       //  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();       //  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\nset&lt;int   &gt; intSet    = intArray.to_set()   ;       //  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();       //  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre>"},{"location":"Array/Operators/","title":"Array Operators","text":""},{"location":"Array/Operators/#array_operators_index","title":"Index operator <code>[]</code>","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\nint intVal = intArray[2];   //  intVal: 0 -&gt; 3\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\nint intVal = intArray[2];   //  intVal: 0 -&gt; 3\n</code></pre> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Array/Operators/#array_operators_assignment","title":"Assignment operator <code>=</code>","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\nintArray[2] = 4;            //  intArray: {1, 2, 3} -&gt; {1, 2, 4}\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\nintArray[2] = 4;            //  intArray: {1, 2, 3} -&gt; {1, 2, 4}\n</code></pre> Note <p>Operator that do not modify contents can be used within exec block or native functions.</p>"},{"location":"Array/Operators/#array_operators_equality","title":"Equality operator <code>==</code>","text":"TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0  = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1  = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 == intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0 == intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0 == stringArray) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 0 (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> <pre><code>int    intArray_0  [2] = {  1 ,  2      };\nint    intArray_1  [3] = {  1 ,  2 ,  3 };\nstring stringArray [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 == intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0 == intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0 == stringArray) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 0 (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Array/Operators/#array_operators_inequality","title":"Inequality operator <code>!=</code>","text":"TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0  = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1  = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 != intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0 != intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 1 (3)\nif (intArray_0 != stringArray) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 1 (4)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> <pre><code>int    intArray_0  [2] = {  1 ,  2      };\nint    intArray_1  [3] = {  1 ,  2 ,  3 };\nstring stringArray [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 != intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0 != intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 1 (2)\nif (intArray_0 != stringArray) bitVal_2 = 1;    //  bitVal_2: 0 -&gt; 1 (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Array/Operators/#array_operators_in","title":"Set membership operator <code>in</code>","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nbit bitVal_0, bitVal_1;\nif (1 in intArray) bitVal_0 = 1;                //  bitval_0: 0 -&gt; 1\nif (0 in intArray) bitVal_1 = 1;                //  bitVal_1: 0 -&gt; 0\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nbit bitVal_0, bitVal_1;\nif (1 in intArray) bitVal_0 = 1;                //  bitval_0: 0 -&gt; 1\nif (0 in intArray) bitVal_1 = 1;                //  bitVal_1: 0 -&gt; 0\n</code></pre> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"Array/Operators/#array_operators_foreach","title":"<code>foreach</code> statement","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nforeach (intArray[i]) {\n    intArray[i] = intArray[i] + 1;  //  intArray: {1, 2, 3} -&gt; {2, 3, 4}\n}\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nforeach (intArray[i]) {\n    intArray[i] = intArray[i] + 1;  //  intArray: {1, 2, 3} -&gt; {2, 3, 4}\n}\n</code></pre> Note <p>Operator that do not modify contents can be used within activity, constraint, native exec code or covergroup.</p>"},{"location":"DataTypes/","title":"Data Types","text":""},{"location":"DataTypes/#integer-types","title":"Integer Types","text":"<p>PSS supports 2 numeric types:</p> Data Type Default Width Default Domain Signed/Unsigned <code>bit</code> 32 bits -2<sup>31</sup>..(2^31-1) Signed <code>int</code> 1 bit 0..1 Unsigned"},{"location":"DataTypes/IntegerTypes/","title":"Integer Types","text":""},{"location":"DataTypes/IntegerTypes/#datatypes_integertypes_bit","title":"Bit","text":"<p><code>bit</code> is a integer data type with default properties: unsigned, 1-bit width, {0, 1} domain.</p>"},{"location":"DataTypes/IntegerTypes/#declare-a-bit","title":"Declare a bit","text":"<pre><code>bit singleBit;\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#declare-8-bits-wide-bit-type","title":"Declare 8-bits wide <code>bit</code> type","text":"<p>Possible values specified by bit width are {0..(2<sup>width</sup>-1)}</p> single bounddual bound <pre><code>bit [8] singleByte;     //  possible values: {0..127};\n</code></pre> <pre><code>bit [7:0] singleByte;   //  possible values: {0..127};\n</code></pre> <p>lower bound must be <code>0</code></p> <p>dual bounds may be removed in future version</p>"},{"location":"DataTypes/IntegerTypes/#declared-with-specified-value-domain","title":"Declared with specified value domain","text":"<p>Values of variable are within intersection of possible values by width and value domain. <pre><code>bit [8] in [0, 1, 5]             singleByte;    //  value domain: {0, 1, 5}\nbit [8] in [..2]                 singleByte;    //  value domain: {0, 1, 2}\nbit [8] in [6..8]                singleByte;    //  value domain: {6, 7, 8}\nbit [8] in [254..]               singleByte;    //  value domain: {254, 255}\nbit [8] in [5, ..2, 6..8, 254..] singleByte;    //  value domain: {0, 1, 2, 5, 6, 7, 8, 254, 255}\n</code></pre></p> <p>Tip</p> <p>Specify value domain is useful for random variable. Following examples are equalize:</p> value domain within declarationvalue domain within <code>constraint</code> <pre><code>rand bit [8] in [5, ..2, 6..8, 253..] singleByte;\n</code></pre> <pre><code>rand bit [8] singleByte;\nconstraint {\n    singleByte in [5, ..2, 6..8, 253..];\n}\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#datatypes_integertypes_integer","title":"Integer","text":"<p><code>int</code> is a integer data type with default properties: signed, 32-bits width, {-2<sup>31</sup>..(2<sup>31</sup>-1)} domain.</p>"},{"location":"DataTypes/IntegerTypes/#declare-an-integer","title":"Declare an integer:","text":"<pre><code>int int32;\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#declare-8-bits-wide-int-type","title":"Declare 8-bits wide <code>int</code> type","text":"<p>Possible values specified by bit width are {-2<sup>width-1</sup>..(2<sup>width-1</sup>-1)}</p> single bounddual bound <pre><code>int [8] int8;       //  possible values: {-128..127}\n</code></pre> <pre><code>int [7:0] int8;     //  possible values: {-128..127}\n</code></pre> <p>lower bound must be <code>0</code></p> <p>dual bounds may be removed in future version</p>"},{"location":"DataTypes/IntegerTypes/#declared-with-specified-value-domain_1","title":"Declared with specified value domain","text":"<p>Values of variable are within intersection of possible values by width and value domain. <pre><code>int [8] in [0, 1, 5]                  int8; //  value domain: {0, 1, 5}\nint [8] in [..(-127)]                 int8; //  value domain: {-128, -127}\nint [8] in [6..8]                     int8; //  value domain: {6, 7, 8}\nint [8] in [126..]                    int8; //  value domain: {126, 127}\nint [8] in [5, ..(-127), 6..8, 253..] int8; //  value domain: {-128, -127, 5, 6, 7, 8, 126, 127}\n</code></pre></p> <p>Tip</p> <p>Specify value domain is useful for random variable. Following examples are equalize:</p> value domain within declarationvalue domain within <code>constraint</code> <pre><code>rand int [8] in [5, ..(-127), 6..8, 253..] int8;\n</code></pre> <pre><code>rand int [8] int8;\nconstraint {\n    int8 in [5, ..(-127), 6..8, 253..];\n}\n</code></pre>"},{"location":"List/","title":"List","text":""},{"location":"List/#declarations","title":"Declarations","text":"<pre><code>list&lt;int     &gt; intList   ;  //  declare an integer list\nlist&lt;bit [8] &gt; byteList  ;  //  declare a byte list\nlist&lt;bool    &gt; boolList  ;  //  declare a bool list\nlist&lt;string  &gt; stringList;  //  declare a string list\nlist&lt;eSTR2NUM&gt; enumList  ;  //  declare an enum list (1)\nlist&lt;sSTR2NUM&gt; structList;  //  declare a struct list (2)\n</code></pre> <ol> <li> <p>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></p> </li> <li> <p>Assume defined struct type before <pre><code>struct sSTR2NUM {\n    string stringVal;\n    int intVal;\n};\n</code></pre></p> </li> </ol>"},{"location":"List/#declare-list-by-rand-keyword","title":"Declare list by <code>rand</code> keyword:","text":"<p> v2.1 <pre><code>rand list&lt;int    &gt; intList   ;\nrand list&lt;bit [8]&gt; byteList  ;\nrand list&lt;string &gt; stringList;\n</code></pre></p>"},{"location":"List/#list-operators","title":"List Operators","text":"Operator Description <code>[]</code> Used to access a specific element of a list. <code>=</code> Creates a copy of the list-type expression on the RHS and assigns it to the list on the LHS. <code>==</code> Evaluates to true if all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true if not all elements with corresponding indexes are equal. <code>in</code> It evaluates to true if the element specified on the left of the operator exists in the list collection on the right of the operator. <code>foreach</code> The foreach statement can be applied to a list to iterate over the list elements."},{"location":"List/#list-methods","title":"List Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the list. <code>clear()</code> Removes all elements. &lt;data_type&gt; <code>delete(index)</code> Move out element at the specified index. <code>insert(index, element)</code> Add element at the specified index. &lt;data_type&gt; <code>pop_front()</code> Move out first element. Same as <code>delete(0)</code>. <code>push_front(element)</code> Add element at beginning of list. Same as <code>insert(0, element)</code>. &lt;data_type&gt; <code>pop_back()</code> Move out last element. Same as <code>delete(size()-1)</code>. <code>push_back(element)</code> Add element at end of list. Same as <code>insert(size(), element)</code>. set&lt;data_type&gt; <code>to_set()</code> Convert list to unordered set. <code>shuffle()</code> v2.1 Randomize orders of elements."},{"location":"List/Methods/","title":"List Methods","text":""},{"location":"List/Methods/#list_methods_size","title":"function int <code>size()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList.size();        //  intVal: 0 -&gt; 3\n</code></pre>"},{"location":"List/Methods/#list_methods_clear","title":"function void <code>clear()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList.clear();                    //  intList: {1, 2, 3} -&gt; {}\n</code></pre>"},{"location":"List/Methods/#list_methods_delete","title":"function &lt;data_type&gt; <code>delete(index)</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList.delete(1);     //  intVal: 0 -&gt; 2; intList: {1, 2, 3} -&gt; {1, 3}\n</code></pre>"},{"location":"List/Methods/#list_methods_insert","title":"function void <code>insert(index, element)</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList.insert(1, 6);               //  intList: {1, 2, 3} -&gt; {1, 6, 2, 3}\n</code></pre>"},{"location":"List/Methods/#list_methods_pop_front","title":"function &lt;data_type&gt; <code>pop_front()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList.pop_front();   //  intVal: 0 -&gt; 1; intList: {1, 2, 3} -&gt; {2, 3}\n</code></pre>"},{"location":"List/Methods/#list_methods_push_front","title":"function void <code>push_front(element)</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList.push_front(4);              //  intList: {1, 2, 3} -&gt; {4, 1, 2, 3}\n</code></pre>"},{"location":"List/Methods/#list_methods_pop_back","title":"function &lt;data_type&gt; <code>pop_back()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList.pop_back();    //  intVal: 0 -&gt; 3; intList: {1, 2, 3} -&gt; {1, 2}\n</code></pre>"},{"location":"List/Methods/#list_methods_push_back","title":"function void <code>push_back(element)</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList.push_back(4);               //  intList: {1, 2, 3} -&gt; {1, 2, 3, 4}\n</code></pre>"},{"location":"List/Methods/#list_methods_to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 1};\nset&lt;int&gt; intSet = intList.to_set(); //  intSet: {} -&gt; {1, 2}\n</code></pre>"},{"location":"List/Methods/#list_methods_shuffle","title":"function void <code>shuffle()</code>","text":"<p> v2.1 <pre><code>list&lt;int&gt; intList = {1, 2};\nintList.shuffle();                  //  intList: {1, 2} -&gt; {1, 2} or {2, 1}\n</code></pre></p>"},{"location":"List/Operators/","title":"List Operators","text":""},{"location":"List/Operators/#list_operators_index","title":"Index operator <code>[]</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nint intVal = intList[1];    //  intVal: 0 -&gt; 2\n</code></pre>"},{"location":"List/Operators/#list_operators_assignment","title":"Assignment operator <code>=</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\nintList[0] = 4;             //  intVal: {1, 2, 3} -&gt; {4, 2, 3}\n</code></pre>"},{"location":"List/Operators/#list_operators_equality","title":"Equality operator <code>==</code>","text":"<pre><code>list&lt;int   &gt; intList_0  = { 1 ,  2 ,  3      };\nlist&lt;int   &gt; intList_1  = { 1 ,  2 ,  3 ,  4 };\nlist&lt;string&gt; stringList = {\"1\", \"2\", \"3\"};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intList_0 == intList_0 ) bitVal_0 = 1;  //  bitVal_0: 0 -&gt; 1; (1)\nif (intList_0 == intList_1 ) bitVal_1 = 1;  //  bitVal_1: 0 -&gt; 0; (2)\nif (intList_0 == stringList) bitVal_2 = 1;  //  bitVal_2: 0 -&gt; 0; (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol>"},{"location":"List/Operators/#list_operators_inequality","title":"Inequality operator <code>!=</code>","text":"<pre><code>list&lt;int   &gt; intList_0  = { 1 ,  2 ,  3      };\nlist&lt;int   &gt; intList_1  = { 1 ,  2 ,  3 ,  4 };\nlist&lt;string&gt; stringList = {\"1\", \"2\", \"3\"};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intList_0 != intList_0 ) bitVal_0 = 1;  //  bitVal_0: 0 -&gt; 0; (1)\nif (intList_0 != intList_1 ) bitVal_1 = 1;  //  bitVal_1: 0 -&gt; 1; (2)\nif (intList_0 != stringList) bitVal_2 = 1;  //  bitVal_2: 0 -&gt; 1; (3)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol>"},{"location":"List/Operators/#list_operators_in","title":"Set membership operator <code>in</code>","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nbit bitVal_0, bitVal_1;\nif ( 1 in intList) bitVal_0 = 1;            //  bitVal_0: 0 -&gt; 1;\nif ( 0 in intList) bitVal_1 = 1;            //  bitVal_1: 0 -&gt; 0;\n</code></pre> Note <p>Operator that do not modify contents can be used within activity, constraint, or covergroup.</p>"},{"location":"List/Operators/#list_operators_foreach","title":"<code>foreach</code> statement","text":"<pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nforeach (intList[i]) {\n    intList[i] = intList[i] + 1;            //  intList: {1, 2, 3} -&gt; {2, 3, 4}\n}\n</code></pre> Note <p>Operator can be used within activity, constraint, or native exec code.</p>"},{"location":"Operator/","title":"Expression Operators","text":""},{"location":"Operator/#expression-operators-and-data-types","title":"Expression operators and data types","text":"Operator token Operator name Operator data types Result data type <code>?:</code> Conditional operator Any plain-data type or reference type Same as operands <code>-</code> Unary arithmetic negation operator Numeric Same as operand <code>~</code> Unary bitwise negation operator Numeric Same as operand <code>!</code> Unary Boolean negation operator Boolean Boolean <code>&amp; | ^</code> Unary bitwise reduction operators Numeric 1-bit <code>+ - * / % **</code> Binary arithmetic operators Numeric 1-bit <code>&amp; | ^</code> Binary bitwise operators Numeric 1-bit <code>&gt;&gt; &lt;&lt;</code> Binary shift operators Numeric Same as left operand <code>&amp;&amp; ||</code> Binary Boolean logical operators Boolean Same as operands <code>&lt; &lt;= &gt; &gt;=</code> Binary relational operators Numeric Boolean <code>== !=</code> Binary logical equality operators Any plain-data type or reference type Boolean <code>cast</code> Data type conversion operator Numeric, Boolean, enum Casting type <code>in</code> Binary set membership operator Any plain-data type Boolean <code>[expression]</code> Index operator Array, list, map Same as element of collection <code>[expression]</code> Bit-select operators Numeric Numeric <code>[expression:expression]</code> Part-select operator Numeric Numeric"},{"location":"Operator/#operator-precedence-and-associativity","title":"Operator precedence and associativity","text":"Operator Associativity Precesence <code>()</code> <code>[]</code> Left 1 (Highest) <code>cast</code> Right 2 <code>-</code> <code>!</code> <code>~</code> <code>&amp;</code> <code>|</code> <code>^</code> (unary) 2 <code>**</code> Left 3 <code>*</code> <code>/</code> <code>%</code> Left 4 <code>+</code> <code>-</code> (binary) Left 5 <code>&lt;&lt;</code> <code>&gt;&gt;</code> Left 6 <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>in</code> Left 7 <code>==</code> <code>!=</code> Left 8 <code>&amp;</code> (binary) Left 9 <code>^</code> (binary) Left 10 <code>|</code> (binary) Left 11 <code>&amp;&amp;</code> Left 12 <code>||</code> Left 13 <code>?:</code> (conditional operator) Right 14 (Lowest)"},{"location":"Operator/Expressions/","title":"Primary Expressions","text":""},{"location":"Operator/Expressions/#bit-selects-and-part-selects","title":"Bit-selects and part-selects","text":""},{"location":"Operator/Expressions/#primary_expressions_bit-selects","title":"Bit-selects","text":"<p>Get a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nbit bitVal = nibbleVal[1];      ///&lt;  bitVal: 0 -&gt; 1\n</code></pre></p> <p>Assign a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[1] = 0;               ///&lt;  nibbleVal: 0b0011 -&gt; 0b0001\n</code></pre></p> <p>Assign a bit of variable by a non-zero integer: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[2] = 2'b10;           ///&lt;  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> <p>Operate a bit of variable by another bit: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[2] |= nibbleVal[1];   ///&lt;  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\nbit bitVal = nibbleVal[10];     ///&lt;  ILLEGAL (1)\nnibbleVal[10] = 1;              ///&lt;  ILLEGAL (2)\nnibbleVal[-1] = 1;              ///&lt;  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>index must be inbound of bit-width.</li> <li>index must be inbound of bit-width.</li> <li>index shall be any integer greater than zero.</li> </ol>"},{"location":"Operator/Expressions/#primary_expressions_part-selects","title":"Part-selects","text":"<p>Get 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nbit [2] bitVal = nibbleVal[1:0];    ///&lt;  bitVal: 0b00 -&gt; 0b11\nbit [2] bitVal = nibbleVal[0:1];    ///&lt;  ILLEGAL SYNTAX (1)\n</code></pre></p> <ol> <li>LSB of range shall be smaller than MSB.</li> </ol> <p>Assign 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[1:0] = 2'b00;             ///&lt;  nibbleVal: 0b0011 -&gt; 0b0000\n</code></pre></p> <p>Operate 2 bits of variable by another 2 bits: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[3:2] |= nibbleVal[1:0];   ///&lt;  nibbleVal: 0b0011 -&gt; 0b1111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\nbit [2] bitVal = nibbleVal[4:3];    ///&lt;  ILLEGAL (1)\nnibbleVal[4:3] = 2'b01;             ///&lt;  ILLEGAL (2)\nnibbleVal[0:-1] = 2'b01;            ///&lt;  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>MSB/LSB of range must be inbound of bit-width.</li> <li>MSB/LSB of range must be inbound of bit-width.</li> <li>MSB/LSB of range shall be any integer greater than zero.</li> </ol>"},{"location":"Operator/Expressions/#primary_expressions_indexing","title":"Selecting an element from a collection (indexing)","text":"<p>Get an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[0]  ;  ///&lt;  nibbleArrayVal: 0 -&gt; 0b1100\nbit [4] nibbleListVal  = nibbleList[1]   ;  ///&lt;  nibbleListVal : 0 -&gt; 0b0110\nbit [4] nibbleMapVal   = nibbleMap[\"ONE\"];  ///&lt;  nibbleMapVal  : 0 -&gt; 0b1100\n</code></pre></p> <p>Assign an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nnibbleArray[0]   = 4'b0011;  ///&lt;  nibbleArray[0]  : 0b1100 -&gt; 0b0011\nnibbleList[0]    = 4'b0011;  ///&lt;  nibbleList[0]   : 0b1100 -&gt; 0b0011\nnibbleMap[\"ONE\"] = 4'b0001;  ///&lt;  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b0001\nnibbleMap[\"TWO\"] = 4'b0110;  ///&lt;  nibbleMap[\"TWO\"]: no_exist -&gt; 0b0110 (1)\n</code></pre></p> <ol> <li><code>map</code> will add the element if no existed.</li> </ol> <p>Operate an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100,        4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100,        4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100, \"TWO\": 4'b0110};\n\nnibbleArray[0]   |= nibbleArray[1]  ;  ///&lt;  nibbleArray[0]  : 0b1100 -&gt; 0b1110\nnibbleList[0]    |= nibbleList[1]   ;  ///&lt;  nibbleList[0]   : 0b1100 -&gt; 0b1110\nnibbleMap[\"ONE\"] |= nibbleMap[\"TWO\"];  ///&lt;  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b1110\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[2]  ;  ///&lt;  ILLEGAL (1)\nbit [4] nibbleListVal  = nibbleList[2]   ;  ///&lt;  ILLEGAL (2)\nbit [4] nibbleMapVal   = nibbleMap[\"TWO\"];  ///&lt;  ILLEGAL (3)\n</code></pre> <ol> <li>index must be inbound of size.</li> <li>index must be inbound of size.</li> <li>The element must be exist in the <code>map</code>.</li> </ol>"},{"location":"Operator/Expressions/#usage","title":"Usage","text":"Access bit of an array <pre><code>array&lt;bit [4], 2&gt; nibbleArray = {4'b1100, 4'b0110};\n\nbit bitOnArray_0_2 = nibbleArray[0][2]; ///&lt;  bitOnArray_0_2: 0 -&gt; 1\nnibbleArray[1][0] = 1;                  ///&lt;  nibbleArray[1]: 0b0110 -&gt; 0b0111\n</code></pre>"}]}