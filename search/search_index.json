{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portable Test and Stimulus Standard (PSS) Cookbook","text":"<p>In this document, we summarize the LRM of PSS, and give you extra examples and tips.</p>"},{"location":"#reference","title":"Reference","text":"<ul> <li>LRM: PSS 2.0 Language Reference Manual</li> <li>LRM: PSS 2.1 Language Reference Manual</li> <li>AndesTech PSS Generator: PSSGen</li> </ul>"},{"location":"Collections/Arrays/","title":"Array","text":""},{"location":"Collections/Arrays/#properties","title":"Properties","text":"<ul> <li>Ordered by index.</li> <li>Randomizable when its data_type is randomizable (e.g., randomizable scalar or aggregate of randomizable scalar).</li> <li>Element and data_type can be any scalar or aggregate of scalar.</li> <li>Index must be positive integer.</li> <li>Size must be non-zero integer.</li> <li>Can be nested by any collection types (e.g., <code>array</code>, <code>list</code>, <code>map</code> or <code>set</code>).</li> </ul>"},{"location":"Collections/Arrays/#declarations","title":"Declarations","text":"<p>Array has 2 declaration formats:</p> Format Syntax <code>Template</code> array&lt;data_type, size&gt; identifier <code>Square</code> data_type identifier [size] TemplateSquare <pre><code>array&lt;int    , 3&gt; intArray   ;          //  intArray   : {   0,    0,    0}\narray&lt;bit [8], 3&gt; byteArray  ;          //  byteArray  : {8'b0, 8'b0, 8'b0}\narray&lt;string , 3&gt; stringArray;          //  stringArray: {  \"\",   \"\",   \"\"}\narray&lt;array&lt;int, 3&gt;, 2&gt; nestedArray;    //  nestedArray: {{0, 0, 0}, {0, 0, 0}}\n</code></pre> <pre><code>int     intArray    [3];                //  intArray   : {   0,    0,    0}\nbit [8] byteArray   [3];                //  byteArray  : {8'b0, 8'b0, 8'b0}\nstring  stringArray [3];                //  stringArray: {  \"\",   \"\",   \"\"}\n// (1)!\n</code></pre> <ol> <li><code>square</code> format NOT support for declare nested array</li> </ol> Note <p>Array is a fixed-size collection, which's size must be assigned by a non-zero integer, and cannot be changed after declared.</p>"},{"location":"Collections/Arrays/#declare-array-by-rand-keyword","title":"Declare array by <code>rand</code> keyword","text":"TemplateSquare <pre><code>rand array&lt;int, 3&gt; intArray;    //  declare integer array with 3 random elements\n</code></pre> <pre><code>rand int intArray [3];          //  declare integer array with 3 random elements\n</code></pre>"},{"location":"Collections/Arrays/#initialization-assignment","title":"Initialization Assignment","text":"<p>Array can be assigned at declaration; otherwise, each elements will be initialized to default initial value.</p> TemplateSquare <pre><code>array&lt;int    , 2&gt; intArray    = {    1,     2};         //  intArray   : {    1,     2}\narray&lt;bit [8], 2&gt; byteArray   = {8'b01, 8'b10};         //  byteArray  : {8'b01, 8'b10}\narray&lt;string , 2&gt; stringArray = {  \"A\",   \"B\"};         //  stringArray: {  \"A\",   \"B\"}\narray&lt;array&lt;int, 2&gt;, 2&gt; nestedArray = {{1, 2}, {3, 4}}; //  nestedArray: {{1, 2}, {3, 4}}\n</code></pre> <pre><code>int     intArray    [2] = {    1,     2};               //  intArray   : {    1,     2}\nbit [8] byteArray   [2] = {8'b01, 8'b10};               //  byteArray  : {8'b01, 8'b10}\nstring  stringArray [2] = {  \"A\",   \"B\"};               //  stringArray: {  \"A\",   \"B\"}\n// (1)!\n</code></pre> <ol> <li><code>square</code> format NOT support for declare nested array</li> </ol>"},{"location":"Collections/Arrays/#array-operators","title":"Array Operators","text":"Operator Description <code>[]</code> Used to access a specific element of an array by given index, which must be a positive integer. <code>=</code> Creates a copy of the <code>array</code>-type expression on the RHS and assigns it to the array on the LHS. <code>==</code> Evaluates to true if both sizes are equal and all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true whether both sizes are not equal or if any element with corresponding index is not equal. <code>in</code> Evaluates to true if element on LHS of <code>in</code> is exists in the array. <code>foreach</code> Iterates over the array's elements."},{"location":"Collections/Arrays/#array-methods","title":"Array Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the array. int <code>sum()</code> Returns the sum of all elements in the array, when data_type of element is <code>bit</code> or <code>int</code>. float64 <code>sum()</code> v2.1 Returns the sum of all elements in the array, when data_type of element is <code>float32</code> or <code>float64</code>. list&lt;data_type&gt; <code>to_list()</code> Returns all elements to a <code>list</code>-type. set&lt;data_type&gt; <code>to_set()</code>: Returns all elements to a <code>set</code>-type."},{"location":"Collections/Arrays/#index","title":"Index operator <code>[]</code>","text":"<p>Used to access a specific element of an array by given index, which must be a positive integer.</p> TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nint intVal = intArray[2];   //  intVal: 0 -&gt; 3\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nint intVal = intArray[2];   //  intVal: 0 -&gt; 3\n</code></pre>"},{"location":"Collections/Arrays/#assignment","title":"Assignment operator <code>=</code>","text":"<p>Creates a copy of the <code>array</code>-type expression on the RHS and assigns it to the array on the LHS.</p> TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nintArray = {3, 4, 5};       //  intArray: {1, 2, 3} -&gt; {3, 4, 5}\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nintArray = {3, 4, 5};       //  intArray: {1, 2, 3} -&gt; {3, 4, 5}\n</code></pre> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Arrays/#equality","title":"Equality operator <code>==</code>","text":"<p>Evaluates to true if both sizes are equal and all elements with corresponding indexes are equal.</p> TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0  = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1  = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 == intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0 == intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0 == stringArray) bitVal_2 = 1;    //  ILLEGAL (3)\n</code></pre> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type between arrays are incomparable.</li> </ol> <pre><code>int    intArray_0  [2] = {  1 ,  2      };\nint    intArray_1  [3] = {  1 ,  2 ,  3 };\nstring stringArray [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 == intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0 == intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0 == stringArray) bitVal_2 = 1;    //  ILLEGAL (3)\n</code></pre> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type between arrays are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of element of two arrays should NOT be compared.</p>"},{"location":"Collections/Arrays/#inequality","title":"Inequality operator <code>!=</code>","text":"<p>Evaluates to true whether both sizes are not equal or if any element with corresponding index is not equal.</p> TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0  = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1  = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 != intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0 != intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 1 (2)\nif (intArray_0 != stringArray) bitVal_2 = 1;    //  ILLEGAL (3)\n</code></pre> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type between arrays are incomparable.</li> </ol> <pre><code>int    intArray_0  [2] = {  1 ,  2      };\nint    intArray_1  [3] = {  1 ,  2 ,  3 };\nstring stringArray [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intArray_0 != intArray_0 ) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0 != intArray_1 ) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 1 (2)\nif (intArray_0 != stringArray) bitVal_2 = 1;    //  ILLEGAL (3)\n</code></pre> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type between arrays are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of element of two arrays should NOT be compared.</p>"},{"location":"Collections/Arrays/#in","title":"Set membership operator <code>in</code>","text":"<p>Evaluates to true if element on LHS of <code>in</code> is exists in the array.</p> TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif ( 1  in intArray) bitVal_0 = 1;              //  bitval_0: 0 -&gt; 1\nif ( 0  in intArray) bitVal_1 = 1;              //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intArray) bitVal_2 = 1;              //  ILLEGAL (1)\n</code></pre> <ol> <li>Different data_type between LHS of <code>in</code> and the array's element on RHS of <code>in</code>.</li> </ol> <pre><code>int intArray [3] = {1, 2, 3};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif ( 1  in intArray) bitVal_0 = 1;              //  bitval_0: 0 -&gt; 1\nif ( 0  in intArray) bitVal_1 = 1;              //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intArray) bitVal_2 = 1;              //  ILLEGAL (1)\n</code></pre> <ol> <li>Different data_type between LHS of <code>in</code> and the array's element on RHS of <code>in</code>.</li> </ol> <p>Warning</p> <p>Data_type of element on LHS of <code>in</code> should be SAME as the array's element on RHS of <code>in</code>.</p>"},{"location":"Collections/Arrays/#foreach","title":"<code>foreach</code> statement","text":"<p>Iterates over the array's elements.</p> TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = {1, 2, 3};\n\nint intVal = 0;\nforeach (intArray[i]) {\n    intVal += intArray[i];                      //  intVal: 0 -&gt; 6\n}\n</code></pre> <pre><code>int intArray [3] = {1, 2, 3};\n\nint intVal = 0;\nforeach (intArray[i]) {\n    intVal += intArray[i];                      //  intVal: 0 -&gt; 6\n}\n</code></pre>"},{"location":"Collections/Arrays/#size","title":"function int <code>size()</code>","text":"<p>Returns the number of elements in the array.</p> TemplateSquare <pre><code>array&lt;int, 2&gt; intArray;\n\nint intVal = intArray.size();       //  intVal: 0 -&gt; 2\n</code></pre> <pre><code>int intArray [2];\n\nint intVal = intArray.size();       //  intVal: 0 -&gt; 2\n</code></pre> Note <p>Considered as a constant expression.</p>"},{"location":"Collections/Arrays/#sum_int","title":"function int <code>sum()</code>","text":"<p>Returns the sum of all elements in the array, when data_type of element is <code>bit</code> or <code>int</code>.</p> TemplateSquare <pre><code>array&lt;int    , 2&gt; intArray    = {  1   ,  2    };\narray&lt;bit [2], 2&gt; bitArray    = { 2'b01, 2'b10 };\narray&lt;string , 2&gt; stringArray = { \"1\"  , \"2\"   };\n\nint intVal_0 = intArray.sum()   ;   //  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;   //  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();   //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <pre><code>int     intArray    [2] = {  1   ,  2    };\nbit [2] bitArray    [2] = { 2'b01, 2'b10 };\nstring  stringArray [2] = { \"1\"  , \"2\"   };\n\nint intVal_0 = intArray.sum()   ;   //  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;   //  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();   //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <p>Warning</p> <p>The <code>data-type</code> of <code>element</code> should be integer types (e.g., <code>int</code> or <code>bit</code>).</p> Usage: use <code>sum()</code> to constrain a random array TemplateSquare <pre><code>rand array&lt;int, 2&gt; intArray;\n\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;   //  intArray: {0, 0} -&gt; {2, 1}\n}\n</code></pre> <pre><code>rand int intArray [2];\n\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;   //  intArray: {0, 0} -&gt; {2, 1}\n}\n</code></pre>"},{"location":"Collections/Arrays/#sum_float","title":"function float64 <code>sum()</code>","text":"<p> v2.1</p> <p>Returns the sum of all elements in the array, when data_type of element is <code>float32</code> or <code>float64</code>.</p> TemplateSquare <pre><code>array&lt;float32, 2&gt; float32Array = {1.0, 2.0};\narray&lt;flaot64, 2&gt; float64Array = {1.0, 2.0};\narray&lt;string , 2&gt; stringArray  = {\"1\", \"2\"};\n\nflaot64 fVal_0 = intArray.sum()   ; //  fVal_0: 0.0 -&gt; 3.0\nflaot64 fVal_1 = bitArray.sum()   ; //  fVal_1: 0.0 -&gt; 3.0\nflaot64 fVal_2 = stringArray.sum(); //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <pre><code>float32 float32Array [2] = {1.0, 2.0};\nflaot64 float64Array [2] = {1.0, 2.0};\nstring  stringArray  [2] = {\"1\", \"2\"};\n\nflaot64 fVal_0 = intArray.sum()   ; //  fVal_0: 0.0 -&gt; 3.0\nflaot64 fVal_1 = bitArray.sum()   ; //  fVal_1: 0.0 -&gt; 3.0\nflaot64 fVal_2 = stringArray.sum(); //  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <p>Warning</p> <p>The <code>data-type</code> of <code>element</code> should be floating-point types (e.g., <code>float32</code> or <code>float64</code>).</p>"},{"location":"Collections/Arrays/#to_list","title":"function list&lt;data_type&gt; <code>to_list()</code>","text":"<p>Returns all elements to a <code>list</code>-type.</p> TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\n\nlist&lt;int   &gt; intList    = intArray.to_list()   ;    //  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();    //  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\n\nlist&lt;int   &gt; intList    = intArray.to_list()   ;    //  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();    //  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre>"},{"location":"Collections/Arrays/#to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>","text":"<p>Returns all elements to a <code>set</code>-type.</p> TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\n\nset&lt;int   &gt; intSet    = intArray.to_set()   ;       //  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();       //  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\n\nset&lt;int   &gt; intSet    = intArray.to_set()   ;       //  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();       //  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre>"},{"location":"Collections/Lists/","title":"List","text":""},{"location":"Collections/Lists/#properties","title":"Properties","text":"<ul> <li>Ordered by index.</li> <li>Randomizable when its data_type is randomizable (e.g., randomizable scalar or aggregate of randomizable scalar).</li> <li>Element and data_type can be any scalar or aggregate of scalar.</li> <li>Index must be positive integer.</li> <li>Can be nested by any collection types (e.g., <code>array</code>, <code>list</code>, <code>map</code> or <code>set</code>).</li> </ul>"},{"location":"Collections/Lists/#declarations","title":"Declarations","text":"<p>List can be declared by following syntax:</p> <p>list&lt;data_type&gt; identifier</p> <pre><code>list&lt;int     &gt; intList   ;  //  intList   : {}\nlist&lt;bit [8] &gt; byteList  ;  //  byteList  : {}\nlist&lt;bool    &gt; boolList  ;  //  boolList  : {}\nlist&lt;string  &gt; stringList;  //  stringList: {}\nlist&lt;eSTR2NUM&gt; enumList  ;  //  enumList  : {} (1)\nlist&lt;sSTR2NUM&gt; structList;  //  structList: {} (2)\n</code></pre> <ol> <li> <p>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></p> </li> <li> <p>Assume defined struct type before <pre><code>struct sSTR2NUM {\n    string stringVal;\n    int intVal;\n};\n</code></pre></p> </li> </ol>"},{"location":"Collections/Lists/#declare-list-by-rand-keyword","title":"Declare list by <code>rand</code> keyword","text":"<p> v2.1 <pre><code>rand list&lt;int    &gt; intList   ;\nrand list&lt;bit [8]&gt; byteList  ;\nrand list&lt;string &gt; stringList;\n</code></pre></p>"},{"location":"Collections/Lists/#initialization-assignment","title":"Initialization Assignment","text":"<p>List can be assigned at declaration; otherwise, it will be initialized to empty aggregate literal (<code>{}</code>). <pre><code>list&lt;int    &gt; intList    = {1    , 2    };  //  intList   : {1    , 2    }\nlist&lt;bit [8]&gt; byteList   = {8'b01, 8'b10};  //  byteList  : {8'b01, 8'b10}\nlist&lt;bool   &gt; boolList   = {false, true };  //  boolList  : {false, true }\nlist&lt;string &gt; stringList = {\"1\"  , \"2\"  };  //  stringList: {\"1\"  , \"2\"  }\n</code></pre></p>"},{"location":"Collections/Lists/#list-operators","title":"List Operators","text":"Operator Description <code>[]</code> Used to access a specific element of a list by given index, which must be a positive integer. <code>=</code> Create a copy of the <code>list</code>-type expression on the RHS and assigns it to the list on the LHS. <code>==</code> Evaluates to true if both sizes are equal and all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true whether both sizes are not equal or if any element with corresponding index is not equal. <code>in</code> Evaluates to true if element on the LHS of <code>in</code> is exists in the list. <code>foreach</code> Iterates over the list's elements."},{"location":"Collections/Lists/#list-methods","title":"List Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the list. <code>clear()</code> Removes all elements from the list. &lt;data_type&gt; <code>delete(int index)</code> Moves out the element at the specified index, which must be a positive integer. <code>insert(int index, data_type element)</code> Adds the element to the specified index, and all elements at and beyond the index are moved by one. &lt;data_type&gt; <code>pop_front()</code> Moves out the first element from the list. Same as <code>delete(0)</code>. <code>push_front(data_type element)</code> Adds the element to the beginning of the list. Same as <code>insert(0, element)</code>. &lt;data_type&gt; <code>pop_back()</code> Moves out the last element from the list. Same as <code>delete(size()-1)</code>. <code>push_back(data_typeelement)</code> Adds the element to the end of the list. Same as <code>insert(size()-1, element)</code>. set&lt;data_type&gt; <code>to_set()</code> Returns all elements to a <code>set</code>-type. <code>shuffle()</code> v2.1 Randomizes orders of elements."},{"location":"Collections/Lists/#index","title":"Index operator <code>[]</code>","text":"<p>Used to access a specific element of a list by given index, which must be a positive integer. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList[1];    //  intVal: 0 -&gt; 2\nint intVal = intList[9];    //  ILLEGAL (1)\n</code></pre></p> <ol> <li>The index is out of bounds.</li> </ol> <p>Warning</p> <p>Index should smaller than <code>size()</code> of the list.</p>"},{"location":"Collections/Lists/#assignment","title":"Assignment operator <code>=</code>","text":"<p>Create a copy of the <code>list</code>-type expression on the RHS and assigns it to the list on the LHS. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList = {2, 3, 4};        //  intList: {1, 2, 3} -&gt; {2, 3, 4}\n</code></pre></p> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#equality","title":"Equality operator <code>==</code>","text":"<p>Evaluates to true if both sizes are equal and all elements with corresponding indexes are equal. <pre><code>list&lt;int   &gt; intList_0  = { 1 ,  2 ,  3      };\nlist&lt;int   &gt; intList_1  = { 1 ,  2 ,  3 ,  4 };\nlist&lt;string&gt; stringList = {\"1\", \"2\", \"3\"};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intList_0 == intList_0 ) bitVal_0 = 1;  //  bitVal_0: 0 -&gt; 1; (1)\nif (intList_0 == intList_1 ) bitVal_1 = 1;  //  bitVal_1: 0 -&gt; 0; (2)\nif (intList_0 == stringList) bitVal_2 = 1;  //  ILLEGAL (3)\n</code></pre></p> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of two lists should NOT be compared.</p>"},{"location":"Collections/Lists/#inequality","title":"Inequality operator <code>!=</code>","text":"<p>Evaluates to true whether both sizes are not equal or if any element with corresponding index is not equal. <pre><code>list&lt;int   &gt; intList_0  = { 1 ,  2 ,  3      };\nlist&lt;int   &gt; intList_1  = { 1 ,  2 ,  3 ,  4 };\nlist&lt;string&gt; stringList = {\"1\", \"2\", \"3\"};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif (intList_0 != intList_0 ) bitVal_0 = 1;  //  bitVal_0: 0 -&gt; 0 (1)\nif (intList_0 != intList_1 ) bitVal_1 = 1;  //  bitVal_1: 0 -&gt; 1 (2)\nif (intList_0 != stringList) bitVal_2 = 1;  //  ILLEGAL (3)\n</code></pre></p> <ol> <li>Equalize size and all elements with corresponding indexes.</li> <li>Inequalize size.</li> <li>Different data_type are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of two lists should NOT be compared.</p>"},{"location":"Collections/Lists/#in","title":"Set membership operator <code>in</code>","text":"<p>Evaluates to true if element on the LHS of <code>in</code> is exists in the list. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif ( 1  in intList) bitVal_0 = 1;           //  bitVal_0: 0 -&gt; 1\nif ( 0  in intList) bitVal_1 = 1;           //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intList) bitVal_2 = 1;           //  ILLEGAL (1)\n</code></pre></p> <ol> <li>Different data_type between LHS of <code>in</code> and the list's element on RHS of <code>in</code>.</li> </ol> <p>Warning</p> <p>Data_type of element on LHS of <code>in</code> should be SAME as the list's element on RHS of <code>in</code>.</p>"},{"location":"Collections/Lists/#foreach","title":"<code>foreach</code> statement","text":"<p>Iterates over the list's elements. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = 0;\nforeach (intList[i]) {\n    intVal += intList[i];                   //  intVal: 0 -&gt; 6\n}\n</code></pre></p>"},{"location":"Collections/Lists/#size","title":"function int <code>size()</code>","text":"<p>Returns the number of elements in the list. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList.size();        //  intVal: 0 -&gt; 3\n</code></pre></p>"},{"location":"Collections/Lists/#clear","title":"function void <code>clear()</code>","text":"<p>Removes all elements from the list. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList.clear();                    //  intList: {1, 2, 3} -&gt; {}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#delete","title":"function &lt;data_type&gt; <code>delete(index)</code>","text":"<p>Moves out the element at the specified index, which must be a positive integer. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList.delete(1);     //  intVal: 0 -&gt; 2; intList: {1, 2, 3} -&gt; {1, 3}\nint intVal = intList.delete(5);     //  ILLEGAL (1)\n</code></pre></p> <ol> <li>The index is out of bounds.</li> </ol> <p>Warning</p> <p>The index must be smaller than <code>size()</code> of the list.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#insert","title":"function void <code>insert(index, element)</code>","text":"<p>Adds the element to the specified index, and all elements at and beyond the index are moved by one. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList.insert(1, 6);               //  intList: {1, 2, 3} -&gt; {1, 6, 2, 3}\nintList.insert(4, 7);               //  intList: {1, 6, 2, 3} -&gt; {1, 6, 2, 3, 7}\nintList.insert(9, 8);               //  ILLEGAL (1)\nintList.insert(0, \"1\");             //  ILLEGAL (2)\n</code></pre></p> <ol> <li>The index is larger than <code>size()</code> of the list.</li> <li>The data_type of elements are not the same.</li> </ol> <p>Warning</p> <p>The index should NOT larger than <code>size()</code> of the list.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#pop_front","title":"function &lt;data_type&gt; <code>pop_front()</code>","text":"<p>Moves out the first element from the list. Same as <code>delete(0)</code>. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList.pop_front();   //  intVal: 0 -&gt; 1; intList: {1, 2, 3} -&gt; {2, 3}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#push_front","title":"function void <code>push_front(element)</code>","text":"<p>Adds the element to the beginning of the list. Same as <code>insert(0, element)</code>. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList.push_front(4);              //  intList: {1, 2, 3} -&gt; {4, 1, 2, 3}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#pop_back","title":"function &lt;data_type&gt; <code>pop_back()</code>","text":"<p>Moves out the last element from the list. Same as <code>delete(size()-1)</code>. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nint intVal = intList.pop_back();    //  intVal: 0 -&gt; 3; intList: {1, 2, 3} -&gt; {1, 2}\n</code></pre></p> Note <p>Method that modify contents can be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#push_back","title":"function void <code>push_back(element)</code>","text":"<p>Adds the element to the end of the list. Same as <code>insert(size()-1, element)</code>. <pre><code>list&lt;int&gt; intList = {1, 2, 3};\n\nintList.push_back(4);               //  intList: {1, 2, 3} -&gt; {1, 2, 3, 4}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Lists/#to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>","text":"<p>Returns all elements to a <code>set</code>-type. <pre><code>list&lt;int&gt; intList = {1, 2, 1};\n\nset&lt;int&gt; intSet = intList.to_set(); //  intSet: {} -&gt; {1, 2}\n</code></pre></p>"},{"location":"Collections/Lists/#shuffle","title":"function void <code>shuffle()</code>","text":"<p> v2.1</p> <p>Randomizes orders of elements. <pre><code>list&lt;int&gt; intList = {1, 2};\n\nintList.shuffle();                  //  intList: {1, 2} -&gt; {1, 2} or {2, 1}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/","title":"Map","text":""},{"location":"Collections/Maps/#properties","title":"Properties","text":"<ul> <li>Unordered.</li> <li>Non-randomizable.</li> <li>Key, element and data_type can be any scalar or aggregate of scalars.</li> <li>Each key must be unique.</li> <li>Can be nested by any collection types (e.g., <code>array</code>, <code>list</code>, <code>map</code> or <code>set</code>).</li> </ul>"},{"location":"Collections/Maps/#declarations","title":"Declarations","text":"<p>Map can be declared by following syntax:</p> <p>map&lt;data_type, data_type&gt; identifier</p> <pre><code>map&lt;bit [4] , int    &gt; nibble2int  ;    //  nibble2int  : {}\nmap&lt;int     , bool   &gt; int2bool    ;    //  int2bool    : {}\nmap&lt;bool    , string &gt; bool2string ;    //  bool2string : {}\nmap&lt;string  , float32&gt; string2float;    //  string2float: {}\nmap&lt;float32 , int    &gt; float2int   ;    //  float2int   : {}\nmap&lt;eSTR2NUM, int    &gt; enum2int    ;    //  enum2int    : {} (1)\n</code></pre> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Maps/#initialization-assignment","title":"Initialization Assignment","text":"<p>Map can be assigned at declaration; otherwise, it will be initialized to empty aggregate literal (<code>{}</code>). <pre><code>map&lt;bit [4] , int    &gt; nibble2int   = {4'b1110:3      , 4'b0110:2     };\nmap&lt;int     , bool   &gt; int2bool     = {      4:true   ,       5:false };\nmap&lt;bool    , string &gt; bool2string  = {  false:\"FALSE\",    true:\"TRUE\"};\nmap&lt;string  , float32&gt; string2float = {  \"2.1\":2.1    ,   \"2.2\":2.2   };\nmap&lt;float32 , int    &gt; float2int    = {    2.4:2      ,     2.6:3     };\nmap&lt;eSTR2NUM, int    &gt; enum2int     = {    ONE:1      ,     TWO:2     }; // (1)!\n</code></pre></p> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Maps/#map-operators","title":"Map Operators","text":"Operator Description <code>[]</code> Used to access a specific element of a map by given key. <code>=</code> Create a copy of the <code>map</code>-type expression on the RHS and assigns it to the map on the LHS. <code>==</code> Evaluates to true if both sizes are equal and all elements with corresponding keys are equal. <code>!=</code> Evaluates to true whether both sizes are not equal or if any element with corresponding key is not equal. <code>foreach</code> Iterates over the map's elements."},{"location":"Collections/Maps/#map-methods","title":"Map Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the map. <code>clear()</code> Removes all *element\"s from the map. &lt;data_type&gt; <code>delete(key)</code> Moves out the element by the specified key, which must exists in the map. <code>insert(key, element)</code> Adds the element with the specified key. set&lt;data_type&gt; <code>keys()</code> Returns all keys to a <code>set</code>-type. list&lt;data_type&gt; <code>values()</code> Returns all elements to a <code>list</code>-type."},{"location":"Collections/Maps/#index","title":"Index operator <code>[]</code>","text":"<p>Used to access a specific element of a map by given key. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nint intVal = string2int[\"2\"];   //  intVal: 0 -&gt; 2;\nint intVal = string2int[\"3\"];   //  ILLEGAL (1)\nint intVal = string2int[ 1 ];   //  ILLEGAL (2)\n</code></pre></p> <ol> <li>The key <code>\"3\"</code> not exist.</li> <li>The data_type of index and key are not the same.</li> </ol> <p>Warning</p> <p>When used to reference an element in the map, the key should be exists.</p> Note <p>When used at LHS for assignment, the key will be added if not exists. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nstring2int[\"3\"] = 3;    //  string2int: {\"1\":0, \"2\":2} -&gt; {\"1\":0, \"2\":2, \"3\":3}\n</code></pre></p> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#assignment","title":"Assignment operator <code>=</code>","text":"<p>Creates a copy of the <code>map</code>-type expression on the RHS and assigns it to the map on the LHS. Last element will be used if there have multiple elements with same key in the expression. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nstring2int = {\"3\":3, \"4\":4};    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"3\":3, \"4\":4}\nstring2int = {3:\"3\", 4:\"4\"};    //  ILLEGAL (1)\n</code></pre></p> <ol> <li>The <code>data_type</code>s are not same as declaration of the map.</li> </ol> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#equality","title":"Equality operator <code>==</code>","text":"<p>Evaluates to true if both sizes are equal and all elements with corresponding keys are equal. <pre><code>map&lt;string, int   &gt; map_0 = {\"1\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_1 = {\"1\":0  , \"2\":2  };\nmap&lt;string, int   &gt; map_2 = {\"0\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_3 = {\"2\":2  , \"1\":1  };\nmap&lt;string, int   &gt; map_4 = {\"1\":1           };\nmap&lt;int   , string&gt; map_5 = {  1:\"1\",   2:\"2\"};\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3, bitVal_4, bitVal_5;\nif (map_0 == map_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 1 (1)\nif (map_0 == map_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 0 (2)\nif (map_0 == map_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 0 (3)\nif (map_0 == map_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 1 (4)\nif (map_0 == map_4) bitVal_4 = 1;   //  bitVal_4: 0 -&gt; 0 (5)\nif (map_0 == map_5) bitVal_5 = 1;   //  ILLEGAL (6)\n</code></pre></p> <ol> <li>Equalize size and all elements with corresponding keys.</li> <li>Inequalize any element with corresponding key.</li> <li>Inequalize any element with corresponding key.</li> <li>Equalize size and all elements with corresponding keys.</li> <li>Inequalize size.</li> <li>Different data_type of key or element are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of key or element of two maps should NOT be compared.</p>"},{"location":"Collections/Maps/#inequality","title":"Inequality operator <code>!=</code>","text":"<p>Evaluates to true whether both sizes are not equal or if any element with corresponding key is not equal. <pre><code>map&lt;string, int   &gt; map_0 = {\"1\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_1 = {\"1\":0  , \"2\":2  };\nmap&lt;string, int   &gt; map_2 = {\"0\":1  , \"2\":2  };\nmap&lt;string, int   &gt; map_3 = {\"2\":2  , \"1\":1  };\nmap&lt;string, int   &gt; map_4 = {\"1\":1           };\nmap&lt;int   , string&gt; map_5 = {  1:\"1\",   2:\"2\"};\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3, bitVal_4, bitVal_5;\nif (map_0 != map_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 0 (1)\nif (map_0 != map_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 1 (2)\nif (map_0 != map_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 1 (3)\nif (map_0 != map_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 0 (4)\nif (map_0 != map_4) bitVal_4 = 1;   //  bitVal_4: 0 -&gt; 1 (5)\nif (map_0 != map_5) bitVal_5 = 1;   //  ILLEGAL (6)\n</code></pre></p> <ol> <li>Equalize size and all elements with corresponding keys.</li> <li>Inequalize any element with corresponding key.</li> <li>Inequalize any element with corresponding key.</li> <li>Equalize size and all elements with corresponding keys.</li> <li>Inequalize size.</li> <li>Different data_type of key or element are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of key or element of two maps should NOT be compared.</p>"},{"location":"Collections/Maps/#foreach","title":"<code>foreach</code> statement","text":"<p>Iterates over the map's elements. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nint intVal = 0;\nforeach (string2int[i]) {\n   intVal += string2int[i];         //  intVal: 0 -&gt; 3\n}\n</code></pre></p>"},{"location":"Collections/Maps/#size","title":"function int <code>size()</code>","text":"<p>Returns the number of elements in the map. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nint intVal = string2int.size(); //  intVal: 0 -&gt; 2\n</code></pre></p>"},{"location":"Collections/Maps/#clear","title":"function void <code>clear()</code>","text":"<p>Removes all *element\"s from the map. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nstring2int.clear(); //  string2int: {\"1\":1, \"2\":2} -&gt; {}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#delete","title":"function &lt;data_type&gt; <code>delete(data_type key)</code>","text":"<p>Moves out the element by the specified key, which must exists in the map. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nmap.delete(\"1\");    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"2\":2}\nmap.delete(\"3\");    //  ILLEGAL (1)\n</code></pre></p> <ol> <li>The key <code>\"3\"</code> is not exist.</li> </ol> <p>Warning</p> <p>The key should be exists in the map.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#insert","title":"function void <code>insert(data_type key, data_type element)</code>","text":"<p>Adds the element with the specified key. The element will be replaced if the key already exists. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2};\n\nstring2int.insert(\"1\", 0  );    //  string2int: {\"1\":1, \"2\":2} -&gt; {\"1\":0, \"2\":2}\nstring2int.insert(\"3\", 3  );    //  string2int: {\"1\":0, \"2\":2} -&gt; {\"1\":0, \"2\":2, \"3\":3}\nstring2int.insert(\"4\", 4.0);    //  ILLEGAL (1)\nstring2int.insert(5  , 5  );    //  ILLEGAL (2)\n</code></pre></p> <ol> <li>The data_type of element is not same.</li> <li>The data_type of key is not same.</li> </ol> <p>Waring</p> <p>The data_type of key or element should be same as the map's declaration.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Maps/#keys","title":"function set&lt;data_type&gt; <code>keys()</code>","text":"<p>Returns all keys to a <code>set</code>-type. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2, \"2.5\":2};\n\nset&lt;string&gt; stringSet = string2int.keys();  //  stringSet: {} -&gt; {\"1\", \"2\", \"2.5\"}\n</code></pre></p>"},{"location":"Collections/Maps/#values","title":"function list&lt;data_type&gt; <code>values()</code>","text":"<p>Returns all elements to a <code>list</code>-type. <pre><code>map&lt;string, int&gt; string2int = {\"1\":1, \"2\":2, \"2.5\":2};\n\nlist&lt;int&gt; intList = string2int.values();    //  intList: {} -&gt; {1, 2, 2}\n</code></pre></p>"},{"location":"Collections/Sets/","title":"Set","text":""},{"location":"Collections/Sets/#properties","title":"Properties","text":"<ul> <li>Unordered.</li> <li>Non-randomizable.</li> <li>Element can be any scalar or aggregate of scalars.</li> <li>Each element must be unique.</li> <li>Can be nested by any collection types (e.g., <code>array</code>, <code>list</code>, <code>map</code> or <code>set</code>).</li> </ul>"},{"location":"Collections/Sets/#declarations","title":"Declarations","text":"<p>Set can be declared by following syntax:</p> <p>set&lt;data_type&gt; identifier</p> <pre><code>set&lt;bit [4] &gt; nibbleSet;    //  nibbleSet: {}\nset&lt;int     &gt; intSet   ;    //  intSet   : {}\nset&lt;bool    &gt; boolSet  ;    //  boolSet  : {}\nset&lt;string  &gt; stringSet;    //  stringSet: {}\nset&lt;float32 &gt; floatSet ;    //  floatSet : {}\nset&lt;eSTR2NUM&gt; enumSet  ;    //  enumSet  : {} (1)\n</code></pre> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Sets/#initialization-assignment","title":"Initialization Assignment","text":"<p>Set can be assigned at declaration; otherwise, it will be initialized to empty aggregate literal (<code>{}</code>). <pre><code>set&lt;bit [4] &gt; nibbleSet = {4'b0001, 4'b0010};\nset&lt;int     &gt; intSet    = {      1, 2      };\nset&lt;bool    &gt; boolSet   = {  false, true   };\nset&lt;string  &gt; stringSet = {    \"1\", \"2\"    };\nset&lt;float32 &gt; floatSet  = {    1.0, 2.0    };\nset&lt;eSTR2NUM&gt; enumSet   = {    ONE, TWO    };   // (1)!\n</code></pre></p> <ol> <li>Assume defined enum type before <pre><code>enum eSTR2NUM {\n    ZERO, ONE, TWO\n};\n</code></pre></li> </ol>"},{"location":"Collections/Sets/#set-operators","title":"Set Operators","text":"Operator Description <code>=</code> Create a copy of the <code>set</code>-type expression on the RHS and assigns it to the set on the LHS. <code>==</code> Evaluetes to true if both sizes are equal and have exactly same elements. <code>!=</code> Evaluetes to true whether both sizes are not equal or do not have exactly same elements. <code>in</code> Evaluetes to true if element on LHS of <code>in</code> is exists in the set. <code>foreach</code> Iterates over the set's elements."},{"location":"Collections/Sets/#set-methods","title":"Set Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the set. <code>clear()</code> Removes all elements from the set. <code>delete(data_type element)</code> Remove the elements from the set. <code>insert(data_type element)</code> Adds the element to the set. list&lt;data_type&gt; <code>to_list()</code> Returns all elements to a <code>list</code>-type."},{"location":"Collections/Sets/#assignment","title":"Assignment operator <code>=</code>","text":"<p>Create a copy of the <code>set</code>-type expression on the RHS and assigns it to the set on the LHS. Same elements in the RHS will be merged automatically and appear only once in the set. <pre><code>set&lt;int&gt; intSet;\n\nintSet = {1, 2};    //  intSet: {}     -&gt; {1, 2}\nintSet = {3, 3, 4}; //  intSet: {1, 2} -&gt; {3, 4} (1)\n</code></pre></p> <ol> <li>Same element will appear only once.</li> </ol> Note <p>Operator that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Sets/#equality","title":"Equality operator <code>==</code>","text":"<p>Evaluetes to true if both sizes are equal and have exactly same elements. <pre><code>set&lt;int   &gt; set_0 = { 1 ,  2      };\nset&lt;int   &gt; set_1 = { 2 ,  1      };\nset&lt;int   &gt; set_2 = { 1 ,  2 ,  3 };\nset&lt;string&gt; set_3 = {\"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (set_0 == set_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 1 (1)\nif (set_0 == set_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 1 (2)\nif (set_0 == set_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 0 (3)\nif (set_0 == set_3) bitVal_3 = 1;   //  ILLEGAL (4)\n</code></pre></p> <ol> <li>Equalize size and all elements.</li> <li>Equalize size and all elements in different order.</li> <li>Inequalize size.</li> <li>Different data_type are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of two sets should NOT be compared.</p>"},{"location":"Collections/Sets/#inequality","title":"Inequality operator <code>!=</code>","text":"<p>Evaluetes to true whether both sizes are not equal or do not have exactly same elements. <pre><code>set&lt;int   &gt; set_0 = { 1 ,  2      };\nset&lt;int   &gt; set_1 = { 2 ,  1      };\nset&lt;int   &gt; set_2 = { 1 ,  2 ,  3 };\nset&lt;string&gt; set_3 = {\"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (set_0 != set_0) bitVal_0 = 1;   //  bitVal_0: 0 -&gt; 0 (1)\nif (set_0 != set_1) bitVal_1 = 1;   //  bitVal_1: 0 -&gt; 0 (2)\nif (set_0 != set_2) bitVal_2 = 1;   //  bitVal_2: 0 -&gt; 1 (3)\nif (set_0 != set_3) bitVal_3 = 1;   //  bitVal_3: 0 -&gt; 1 (4)\n</code></pre></p> <ol> <li>Equalize size, and all elements.</li> <li>Equalize size, and all elements in different order.</li> <li>Inequalize size.</li> <li>Different data_type are incomparable.</li> </ol> <p>Warning</p> <p>Different data_type of two sets should NOT be compared.</p>"},{"location":"Collections/Sets/#in","title":"Set membership operator <code>in</code>","text":"<p>Evaluetes to true if element on LHS of <code>in</code> is exists in the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nbit bitVal_0, bitVal_1, bitVal_2;\nif ( 1  in intSet) bitVal_0 = 1;    //  bitVal_0: 0 -&gt; 1\nif ( 3  in intSet) bitVal_1 = 1;    //  bitVal_1: 0 -&gt; 0\nif (\"1\" in intSet) bitVal_2 = 1;    //  ILLEGAL (1)\n</code></pre></p> <ol> <li>Different data_type between LHS of <code>in</code> and the set's element on RHS of <code>in</code>.</li> </ol> <p>Warning</p> <p>Data_type of element on LHS of <code>in</code> should be SAME as the set's element on RHS of <code>in</code>.</p>"},{"location":"Collections/Sets/#foreach","title":"<code>foreach</code> statement","text":"<p>Iterates over the set's elements. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nint intVal = 0;\nforeach (i:intSet) {\n    intVal += i;                    //  intVal: 0 -&gt; 3\n}\n</code></pre></p> Warning <p>For <code>set</code>-type, index variable of <code>foreach</code> statament should NOT be used to specify <code>set</code> elements. <pre><code>foreach (intSet[i]) {}  //  ILLEGAL\n</code></pre></p>"},{"location":"Collections/Sets/#size","title":"function int <code>size()</code>","text":"<p>Returns the number of elements in the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nint intVal = intSet.size(); //  intVal: 0 -&gt; 2\n</code></pre></p>"},{"location":"Collections/Sets/#clear","title":"function void <code>clear()</code>","text":"<p>Removes all elements from the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.clear(); // intSet: {1, 2} -&gt; {}\n</code></pre></p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Sets/#delete","title":"function void <code>delete(data_type element)</code>","text":"<p>Removes the elements from the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.delete( 2 ); //  intSet: {1, 2} -&gt; {1}\nintSet.delete( 3 ); //  ILLEGAL (1)\nintSet.delete(\"1\"); //  ILLEGAL (2)\n</code></pre></p> <ol> <li>The element is not exist in the set.</li> <li>Data-type of the element is not same as the set.</li> </ol> <p>Warning</p> <p>The element need to deleted should exists in the set.</p> Note <p>Different to <code>list</code>-type or <code>map</code>-type, <code>delete(data_type element)</code> of <code>set</code>-type will not return the element.</p> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Sets/#insert","title":"function void <code>insert(data_type element)</code>","text":"<p>Adds the element to the set. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nintSet.insert( 3 ); //  intSet: {1, 2}    -&gt; {1, 2, 3}\nintSet.insert( 2 ); //  intSet: {1, 2, 3} -&gt; {1, 2, 3}\nintSet.insert(\"4\"); //  ILLEGAL (1)\n</code></pre></p> <ol> <li>Data-type of the element is not same as the set.</li> </ol> Note <p>Method that modify contents can only be used within <code>exec</code> block or native <code>function</code>.</p>"},{"location":"Collections/Sets/#to_list","title":"function list&lt;data_type&gt; <code>to_list()</code>","text":"<p>Returns all elements to a <code>list</code>-type. <pre><code>set&lt;int&gt; intSet = {1, 2};\n\nlist&lt;int&gt; intList = intSet.to_list();   //  intList: {} -&gt; {1, 2}\n</code></pre></p>"},{"location":"DataTypes/","title":"Data Types","text":""},{"location":"DataTypes/#datatypes_scalar","title":"Scalar Type","text":"Scalar Type Randomizable <code>bit</code> <code>int</code> <code>bool</code> <code>enum</code> <code>string</code> <code>float32</code> v2.1 <code>float64</code> v2.1 <code>chandle</code>"},{"location":"DataTypes/#datatypes_aggregate","title":"Aggregate","text":"Aggregate Type Randomizable <code>array</code>  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code> <code>list</code>  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code> v2.1 <code>map</code> <code>set</code> <code>struct</code>  Only for <code>bit</code>, <code>int</code>, <code>bool</code>, <code>enum</code>, <code>string</code> <p>Aggregate may be nested.</p>"},{"location":"DataTypes/#datatypes_non_aggregate","title":"Non-aggregate","text":"<ul> <li><code>component</code></li> <li><code>action</code></li> <li><code>buffer</code></li> <li><code>stream</code></li> <li><code>state</code></li> <li><code>resource</code></li> </ul>"},{"location":"DataTypes/IntegerTypes/","title":"Integer Types","text":""},{"location":"DataTypes/IntegerTypes/#datatypes_integertypes_bit","title":"Bit","text":"<p><code>bit</code> is a integer data type with default properties: unsigned, 1-bit width, {0, 1} domain.</p>"},{"location":"DataTypes/IntegerTypes/#declare-a-bit","title":"Declare a bit","text":"<pre><code>bit singleBit;\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#declare-8-bits-wide-bit-type","title":"Declare 8-bits wide <code>bit</code> type","text":"<p>Possible values specified by bit width are {0..(2<sup>width</sup>-1)}</p> single bounddual bound <pre><code>bit [8] singleByte;     //  possible values: {0..127};\n</code></pre> <pre><code>bit [7:0] singleByte;   //  possible values: {0..127};\n</code></pre> <p>lower bound must be <code>0</code></p> <p>dual bounds may be removed in future version</p>"},{"location":"DataTypes/IntegerTypes/#declared-with-specified-value-domain","title":"Declared with specified value domain","text":"<p>Values of variable are within intersection of possible values by width and value domain. <pre><code>bit [8] in [0, 1, 5]             singleByte;    //  value domain: {0, 1, 5}\nbit [8] in [..2]                 singleByte;    //  value domain: {0, 1, 2}\nbit [8] in [6..8]                singleByte;    //  value domain: {6, 7, 8}\nbit [8] in [254..]               singleByte;    //  value domain: {254, 255}\nbit [8] in [5, ..2, 6..8, 254..] singleByte;    //  value domain: {0, 1, 2, 5, 6, 7, 8, 254, 255}\n</code></pre></p> <p>Tip</p> <p>Specify value domain is useful for random variable. Following examples are equalize:</p> value domain within declarationvalue domain within <code>constraint</code> <pre><code>rand bit [8] in [5, ..2, 6..8, 253..] singleByte;\n</code></pre> <pre><code>rand bit [8] singleByte;\nconstraint {\n    singleByte in [5, ..2, 6..8, 253..];\n}\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#datatypes_integertypes_integer","title":"Integer","text":"<p><code>int</code> is a integer data type with default properties: signed, 32-bits width, {-2<sup>31</sup>..(2<sup>31</sup>-1)} domain.</p>"},{"location":"DataTypes/IntegerTypes/#declare-an-integer","title":"Declare an integer:","text":"<pre><code>int int32;\n</code></pre>"},{"location":"DataTypes/IntegerTypes/#declare-8-bits-wide-int-type","title":"Declare 8-bits wide <code>int</code> type","text":"<p>Possible values specified by bit width are {-2<sup>width-1</sup>..(2<sup>width-1</sup>-1)}</p> single bounddual bound <pre><code>int [8] int8;       //  possible values: {-128..127}\n</code></pre> <pre><code>int [7:0] int8;     //  possible values: {-128..127}\n</code></pre> <p>lower bound must be <code>0</code></p> <p>dual bounds may be removed in future version</p>"},{"location":"DataTypes/IntegerTypes/#declared-with-specified-value-domain_1","title":"Declared with specified value domain","text":"<p>Values of variable are within intersection of possible values by width and value domain. <pre><code>int [8] in [0, 1, 5]                  int8; //  value domain: {0, 1, 5}\nint [8] in [..(-127)]                 int8; //  value domain: {-128, -127}\nint [8] in [6..8]                     int8; //  value domain: {6, 7, 8}\nint [8] in [126..]                    int8; //  value domain: {126, 127}\nint [8] in [5, ..(-127), 6..8, 253..] int8; //  value domain: {-128, -127, 5, 6, 7, 8, 126, 127}\n</code></pre></p> <p>Tip</p> <p>Specify value domain is useful for random variable. Following examples are equalize:</p> value domain within declarationvalue domain within <code>constraint</code> <pre><code>rand int [8] in [5, ..(-127), 6..8, 253..] int8;\n</code></pre> <pre><code>rand int [8] int8;\nconstraint {\n    int8 in [5, ..(-127), 6..8, 253..];\n}\n</code></pre>"},{"location":"Operator/","title":"Operators and Expressions","text":""},{"location":"Operator/#assignment-operators","title":"Assignment Operators","text":"<p>Work in Progress</p>"},{"location":"Operator/#expression-operators-and-data-types","title":"Expression operators and data types","text":"Operator token Operator name Operator data types Result data type <code>?:</code> Conditional operator Any plain-data type or reference type Same as operands <code>-</code> Unary arithmetic negation operator Numeric Same as operand <code>~</code> Unary bitwise negation operator Numeric Same as operand <code>!</code> Unary Boolean negation operator Boolean Boolean <code>&amp; | ^</code> Unary bitwise reduction operators Numeric 1-bit <code>+ - * / % **</code> Binary arithmetic operators Numeric 1-bit <code>&amp; | ^</code> Binary bitwise operators Numeric 1-bit <code>&gt;&gt; &lt;&lt;</code> Binary shift operators Numeric Same as left operand <code>&amp;&amp; ||</code> Binary Boolean logical operators Boolean Same as operands <code>&lt; &lt;= &gt; &gt;=</code> Binary relational operators Numeric Boolean <code>== !=</code> Binary logical equality operators Any plain-data type or reference type Boolean <code>cast</code> Data type conversion operator Numeric, Boolean, enum Casting type <code>in</code> Binary set membership operator Any plain-data type Boolean <code>[expression]</code> Index operator Array, list, map Same as element of collection <code>[expression]</code> Bit-select operators Numeric Numeric <code>[expression:expression]</code> Part-select operator Numeric Numeric"},{"location":"Operator/#operator-precedence-and-associativity","title":"Operator precedence and associativity","text":"Operator Associativity Precesence <code>()</code> <code>[]</code> Left 1 (Highest) <code>cast</code> Right 2 <code>-</code> <code>!</code> <code>~</code> <code>&amp;</code> <code>|</code> <code>^</code> (unary) 2 <code>**</code> Left 3 <code>*</code> <code>/</code> <code>%</code> Left 4 <code>+</code> <code>-</code> (binary) Left 5 <code>&lt;&lt;</code> <code>&gt;&gt;</code> Left 6 <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>in</code> Left 7 <code>==</code> <code>!=</code> Left 8 <code>&amp;</code> (binary) Left 9 <code>^</code> (binary) Left 10 <code>|</code> (binary) Left 11 <code>&amp;&amp;</code> Left 12 <code>||</code> Left 13 <code>?:</code> (conditional operator) Right 14 (Lowest)"},{"location":"Operator/BinaryBitwise/","title":"Binary Bitwise Operators","text":"<p>PSS supports 3 basic bitwise operators: 1. Bitwise AND <code>&amp;</code> 2. Bitwise OR <code>|</code> 3. Bitwise XOR <code>^</code></p>"},{"location":"Operator/BinaryBitwise/#constant-op-constant","title":"CONSTANT op CONSTANT","text":"<pre><code>bit [8] byteAND = 8'b0110_1001 &amp; 8'b0000_1111;  //  byteAND: 0 -&gt; 8'b0000_1001\nbit [8] byteOR  = 8'b0110_1001 | 8'b0000_1111;  //  byteOR : 0 -&gt; 8'b0110_1111\nbit [8] byteXOR = 8'b0110_1001 ^ 8'b0000_1111;  //  byteXOR: 0 -&gt; 8'b0110_0110\n</code></pre>"},{"location":"Operator/Expressions/","title":"Primary Expressions","text":""},{"location":"Operator/Expressions/#bit-selects-and-part-selects","title":"Bit-selects and part-selects","text":""},{"location":"Operator/Expressions/#primary_expressions_bit-selects","title":"Bit-selects","text":"<p>Get a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nbit bitVal = nibbleVal[1];      ///&lt;  bitVal: 0 -&gt; 1\n</code></pre></p> <p>Assign a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[1] = 0;               ///&lt;  nibbleVal: 0b0011 -&gt; 0b0001\n</code></pre></p> <p>Assign a bit of variable by a non-zero integer: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[2] = 2'b10;           ///&lt;  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> <p>Operate a bit of variable by another bit: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[2] |= nibbleVal[1];   ///&lt;  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\nbit bitVal = nibbleVal[10];     ///&lt;  ILLEGAL (1)\nnibbleVal[10] = 1;              ///&lt;  ILLEGAL (2)\nnibbleVal[-1] = 1;              ///&lt;  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>index must be inbound of bit-width.</li> <li>index must be inbound of bit-width.</li> <li>index shall be any integer greater than zero.</li> </ol>"},{"location":"Operator/Expressions/#primary_expressions_part-selects","title":"Part-selects","text":"<p>Get 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nbit [2] bitVal = nibbleVal[1:0];    ///&lt;  bitVal: 0b00 -&gt; 0b11\nbit [2] bitVal = nibbleVal[0:1];    ///&lt;  ILLEGAL SYNTAX (1)\n</code></pre></p> <ol> <li>LSB of range shall be smaller than MSB.</li> </ol> <p>Assign 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[1:0] = 2'b00;             ///&lt;  nibbleVal: 0b0011 -&gt; 0b0000\n</code></pre></p> <p>Operate 2 bits of variable by another 2 bits: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[3:2] |= nibbleVal[1:0];   ///&lt;  nibbleVal: 0b0011 -&gt; 0b1111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\nbit [2] bitVal = nibbleVal[4:3];    ///&lt;  ILLEGAL (1)\nnibbleVal[4:3] = 2'b01;             ///&lt;  ILLEGAL (2)\nnibbleVal[0:-1] = 2'b01;            ///&lt;  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>MSB/LSB of range must be inbound of bit-width.</li> <li>MSB/LSB of range must be inbound of bit-width.</li> <li>MSB/LSB of range shall be any integer greater than zero.</li> </ol>"},{"location":"Operator/Expressions/#primary_expressions_indexing","title":"Selecting an element from a collection (indexing)","text":"<p>Get an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[0]  ;  ///&lt;  nibbleArrayVal: 0 -&gt; 0b1100\nbit [4] nibbleListVal  = nibbleList[1]   ;  ///&lt;  nibbleListVal : 0 -&gt; 0b0110\nbit [4] nibbleMapVal   = nibbleMap[\"ONE\"];  ///&lt;  nibbleMapVal  : 0 -&gt; 0b1100\n</code></pre></p> <p>Assign an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nnibbleArray[0]   = 4'b0011;  ///&lt;  nibbleArray[0]  : 0b1100 -&gt; 0b0011\nnibbleList[0]    = 4'b0011;  ///&lt;  nibbleList[0]   : 0b1100 -&gt; 0b0011\nnibbleMap[\"ONE\"] = 4'b0001;  ///&lt;  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b0001\nnibbleMap[\"TWO\"] = 4'b0110;  ///&lt;  nibbleMap[\"TWO\"]: no_exist -&gt; 0b0110 (1)\n</code></pre></p> <ol> <li><code>map</code> will add the element if no existed.</li> </ol> <p>Operate an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100,        4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100,        4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100, \"TWO\": 4'b0110};\n\nnibbleArray[0]   |= nibbleArray[1]  ;  ///&lt;  nibbleArray[0]  : 0b1100 -&gt; 0b1110\nnibbleList[0]    |= nibbleList[1]   ;  ///&lt;  nibbleList[0]   : 0b1100 -&gt; 0b1110\nnibbleMap[\"ONE\"] |= nibbleMap[\"TWO\"];  ///&lt;  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b1110\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[2]  ;  ///&lt;  ILLEGAL (1)\nbit [4] nibbleListVal  = nibbleList[2]   ;  ///&lt;  ILLEGAL (2)\nbit [4] nibbleMapVal   = nibbleMap[\"TWO\"];  ///&lt;  ILLEGAL (3)\n</code></pre> <ol> <li>index must be inbound of size.</li> <li>index must be inbound of size.</li> <li>The element must be exist in the <code>map</code>.</li> </ol>"},{"location":"Operator/Expressions/#usage","title":"Usage","text":"Access bit of an array <pre><code>array&lt;bit [4], 2&gt; nibbleArray = {4'b1100, 4'b0110};\n\nbit bitOnArray_0_2 = nibbleArray[0][2]; ///&lt;  bitOnArray_0_2: 0 -&gt; 1\nnibbleArray[1][0] = 1;                  ///&lt;  nibbleArray[1]: 0b0110 -&gt; 0b0111\n</code></pre>"},{"location":"Traversal/","title":"Traversal","text":""},{"location":"Traversal/#traversal-context","title":"Traversal Context","text":"Context Semantics <code>parallel</code> All array elements are scheduled for traversal in parallel. <code>schedule</code> All array elements are scheduled for traversal independently. <code>select</code> One array element is randomly selected and traversed. <code>sequence</code> All array elements are scheduled for traversal in sequence from <code>0</code> to <code>N-1</code>."},{"location":"Traversal/#traversal_parallel","title":"<code>parallel</code>","text":"<p>Work in Progress</p>"},{"location":"Traversal/#traversal_schedule","title":"<code>schedule</code>","text":"<p>Both actions (i.e., sub with \"Hello\" and \"World\") in <code>schedule</code> block will be traversed in random order. <pre><code>action top {\n    activity {\n        schedule {\n            do sub with { str == \"Hello\"; };\n            do sub with { str == \"World\"; };\n        }\n    }\n}\n\naction sub {\n    rand string str;\n    exec body ASM = \"\"\"{{str}}\"\"\";\n}\n</code></pre></p> <p>There have two possible results:</p> \"Hello\" first\"World\" first <pre><code>Hello\nWorld\n</code></pre> <pre><code>World\nHello\n</code></pre>"},{"location":"Traversal/#traversal_select","title":"<code>select</code>","text":"<p>Only one action in <code>select</code> block will be chosen and traversed. <pre><code>action top {\n    activity {\n        select {\n            do sub with { str == \"Hello\"; };\n            do sub with { str == \"World\"; };\n        }\n    }\n}\n\naction sub {\n    rand string str;\n    exec body ASM = \"\"\"{{str}}\"\"\";\n}\n</code></pre></p> <p>There have two possible results:</p> \"Hello\" chosen\"World\" chosen <pre><code>Hello\n</code></pre> <pre><code>World\n</code></pre>"},{"location":"Traversal/#traversal_sequence","title":"<code>sequence</code>","text":"<p>Work in Progress</p>"}]}