{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portable Test and Stimulus Standard (PSS) CookBook","text":"<p>In this document, we summarize the LRM of PSS, and give you extra examples and tips.</p>"},{"location":"#reference","title":"Reference","text":"<p>LRM: PSS 2.0 Language Reference Manual AndesTech PSS Generator: PSSGen</p>"},{"location":"Array/","title":"Array","text":""},{"location":"Array/#declarations","title":"Declarations","text":"<p>Array has 2 types of declare syntaxes: <code>Template</code>, <code>Square</code>.</p> TemplateSquare <pre><code>array&lt;int    , 3&gt; intArray   ;  ///&lt;  declare integer array with 3 elements\narray&lt;bit [8], 3&gt; byteArray  ;  ///&lt;  declare byte array with 3 elements\narray&lt;string , 3&gt; stringArray;  ///&lt;  declare string array with 3 elements\narray&lt;array&lt;int, 3&gt;, 2&gt; nestedArray;    ///&lt;  declare nested array with 3x2 integer elements\n</code></pre> <pre><code>int     intArray    [3];        ///&lt;  declare integer array with 3 elements\nbit [8] byteArray   [3];        ///&lt;  declare byte array with 3 elements\nstring  stringArray [3];        ///&lt;  declare string array with 3 elements\n///&lt; (1)!\n</code></pre> <ol> <li><code>square</code> not support for declare nested array</li> </ol> <p>Declare array by <code>rand</code> keyword:</p> TemplateSquare <pre><code>rand array&lt;int, 3&gt; intArray;    ///&lt;  declare integer array with 3 random elements\n</code></pre> <pre><code>rand int intArray [3];          ///&lt;  declare integer array with 3 random elements\n</code></pre>"},{"location":"Array/#array-operators","title":"Array Operators","text":"Operator Description <code>[]</code> Used to access a specific element of an array. <code>=</code> Creates a copy of the array-type expression on the RHS and assigns it to the array on the LHS. <code>==</code> Evaluates to true if all elements with corresponding indexes are equal. <code>!=</code> Evaluates to true if not all elements with corresponding indexes are equal. <code>in</code> It evaluates to true if the element specified on the left of the operator exists in the array collection on the right of the operator. <code>foreach</code> The foreach statement can be applied to an array to iterate over the array elements."},{"location":"Array/#array-methods","title":"Array Methods","text":"Method Description int <code>size()</code> Returns the number of elements in the arrays. int <code>sum()</code> Returns the sum of all elements currently stored in the array. list&lt;data_type&gt; <code>to_list()</code> Returns a list containing the elements of the array. set&lt;data_type&gt; <code>to_set()</code>: Returns a set containing the elements of the array."},{"location":"Array/Methods/","title":"Array Methods","text":"<p>Methods that do not modify contents (e.g., <code>size()</code>, <code>sum()</code>, <code>to_list()</code>, <code>to_set()</code>) may be used in activity, constraint, and covergroup. </p>"},{"location":"Array/Methods/#array_methods_to_size","title":"function int <code>size()</code>:","text":"TemplateSquare <pre><code>array&lt;int, 2&gt; intArray;\nint intVal = intArray.size();  ///&lt;  intVal: 0 -&gt; 2\n</code></pre> <pre><code>int intArray [2];\nint intVal = intArray.size();  ///&lt;  intVal: 0 -&gt; 2\n</code></pre> Note <p>Considered as a constant expression.</p>"},{"location":"Array/Methods/#array_methods_sum","title":"function int <code>sum()</code>:","text":"TemplateSquare <pre><code>array&lt;int    , 2&gt; intArray    = {  1   ,  2    };\narray&lt;bit [2], 2&gt; bitArray    = { 2'b01, 2'b10 };\narray&lt;string , 2&gt; stringArray = { \"1\"  , \"2\"   };\nint intVal_0 = intArray.sum()   ;  ///&lt;  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;  ///&lt;  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();  ///&lt;  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> <pre><code>int     intArray    [2] = {  1   ,  2    };\nbit [2] bitArray    [2] = { 2'b01, 2'b10 };\nstring  stringArray [2] = { \"1\"  , \"2\"   };\nint intVal_0 = intArray.sum()   ;  ///&lt;  intVal_0: 0 -&gt; 3\nint intVal_1 = bitArray.sum()   ;  ///&lt;  intVal_1: 0 -&gt; 3\nint intVal_2 = stringArray.sum();  ///&lt;  ILLEGAL (1)\n</code></pre> <ol> <li><code>string</code> can't be calculated</li> </ol> Note <p>Only can used on numeric data type (<code>int</code> or <code>bit</code>).</p> Usage: use <code>sum()</code> to constrain a random array TemplateSquare <pre><code>rand array&lt;int, 2&gt; intArray;\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;  ///&lt;  intArray: {?, ?} -&gt; {2, 1}\n}\n</code></pre> <pre><code>rand int intArray [2];\nconstraint {\n    intArray.sum() == 3;\n    intArray[0] == 2;  ///&lt;  intArray: {?, ?} -&gt; {2, 1}\n}\n</code></pre>"},{"location":"Array/Methods/#array_methods_to_list","title":"function list&lt;data_type&gt; <code>to_list()</code>:","text":"TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\nlist&lt;int   &gt; intList    = intArray.to_list()   ;  ///&lt;  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();  ///&lt;  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\nlist&lt;int   &gt; intList    = intArray.to_list()   ;  ///&lt;  intList: {} -&gt; {2, 1, 2}\nlist&lt;string&gt; stringList = stringArray.to_list();  ///&lt;  stringList: {} -&gt; {\"2\", \"1\", \"2\"};\n</code></pre>"},{"location":"Array/Methods/#array_methods_to_set","title":"function set&lt;data_type&gt; <code>to_set()</code>:","text":"TemplateSquare <pre><code>array&lt;int   , 3&gt; intArray    = {  2 ,  1 ,  2  };\narray&lt;string, 3&gt; stringArray = { \"2\", \"1\", \"2\" };\nset&lt;int   &gt; intSet    = intArray.to_set()   ;  ///&lt;  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();  ///&lt;  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre> <pre><code>int    intArray    [3] = {  2 ,  1 ,  2  };\nstring stringArray [3] = { \"2\", \"1\", \"2\" };\nset&lt;int   &gt; intSet    = intArray.to_set()   ;  ///&lt;  intSet: {} -&gt; {2, 1}\nset&lt;string&gt; stringSet = stringArray.to_set();  ///&lt;  stringSet: {} -&gt; {\"2\", \"1\"}\n</code></pre>"},{"location":"Array/Operators/","title":"Array Operators","text":""},{"location":"Array/Operators/#array_operators_index","title":"Index operator <code>[]</code>:","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray;\nint intVal = intArray[2];  ///&lt;  get element 2 of intArray;\n</code></pre> <pre><code>int intArray [3];\nint intVal = intArray[2];  ///&lt;  get element 2 of intArray;\n</code></pre> Note <p>Operator that do not modify contents may be used in activity, constraint, and covergroup.</p>"},{"location":"Array/Operators/#array_operators_assignment","title":"Assignment operator <code>=</code>:","text":"TemplateSquare <pre><code>array&lt;int, 3&gt; intArray = { 1, 2, 3 };   ///&lt;  assign values while declaration\nintArray[2] = intArray[1];              ///&lt;  assign value of element 2 by element 1\n</code></pre> <pre><code>int intArray [3] = { 1, 2, 3 };         ///&lt;  assign values while declaration\nintArray[2] = intArray[1];              ///&lt;  assign value of element 2 by element 1\n</code></pre> Note <p>Operator that do not modify contents may be used in exec block and native functions.</p>"},{"location":"Array/Operators/#array_operators_equality","title":"Equality operator <code>==</code>:","text":"TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0    = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1    = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray_0 = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (intArray_0    == intArray_0   ) bitVal_0 = 1;  ///&lt;  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0[1] == intArray_1[1]) bitVal_1 = 1;  ///&lt;  bitVal_1: 0 -&gt; 1 (2)\nif (intArray_0    == intArray_1   ) bitVal_2 = 1;  ///&lt;  bitVal_2: 0 -&gt; 0 (3)\nif (intArray_0    == stringArray_0) bitVal_3 = 1;  ///&lt;  bitVal_3: 0 -&gt; 0 (4)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Equalize type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> <pre><code>int    intArray_0    [2] = {  1 ,  2      };\nint    intArray_1    [3] = {  1 ,  2 ,  3 };\nstring stringArray_0 [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (intArray_0    == intArray_0   ) bitVal_0 = 1;  ///&lt;  bitVal_0: 0 -&gt; 1 (1)\nif (intArray_0[1] == intArray_1[1]) bitVal_1 = 1;  ///&lt;  bitVal_1: 0 -&gt; 1 (2)\nif (intArray_0    == intArray_1   ) bitVal_2 = 1;  ///&lt;  bitVal_2: 0 -&gt; 0 (3)\nif (intArray_0    == stringArray_0) bitVal_3 = 1;  ///&lt;  bitVal_3: 0 -&gt; 0 (4)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Equalize type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> Note <p>Operator that do not modify contents may be used in activity, constraint, and covergroup.</p>"},{"location":"Array/Operators/#array_operators_inequality","title":"Inequality operator <code>!=</code>:","text":"TemplateSquare <pre><code>array&lt;int   , 2&gt; intArray_0    = {  1 ,  2      };\narray&lt;int   , 3&gt; intArray_1    = {  1 ,  2 ,  3 };\narray&lt;string, 2&gt; stringArray_0 = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (intArray_0    != intArray_0   ) bitVal_0 = 1;  ///&lt;  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0[1] != intArray_1[1]) bitVal_1 = 1;  ///&lt;  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0    != intArray_1   ) bitVal_2 = 1;  ///&lt;  bitVal_2: 0 -&gt; 1 (3)\nif (intArray_0    != stringArray_0) bitVal_3 = 1;  ///&lt;  bitVal_3: 0 -&gt; 1 (4)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Equalize type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> <pre><code>int    intArray_0    [2] = {  1 ,  2      };\nint    intArray_1    [3] = {  1 ,  2 ,  3 };\nstring stringArray_0 [2] = { \"1\", \"2\"     };\n\nbit bitVal_0, bitVal_1, bitVal_2, bitVal_3;\nif (intArray_0    != intArray_0   ) bitVal_0 = 1;  ///&lt;  bitVal_0: 0 -&gt; 0 (1)\nif (intArray_0[1] != intArray_1[1]) bitVal_1 = 1;  ///&lt;  bitVal_1: 0 -&gt; 0 (2)\nif (intArray_0    != intArray_1   ) bitVal_2 = 1;  ///&lt;  bitVal_2: 0 -&gt; 1 (3)\nif (intArray_0    != stringArray_0) bitVal_3 = 1;  ///&lt;  bitVal_3: 0 -&gt; 1 (4)\n</code></pre> <ol> <li>Equalize size, type, context.</li> <li>Equalize type, context.</li> <li>Inequalize size, context.</li> <li>Inequalize type.</li> </ol> Note <p>Operator that do not modify contents may be used in activity, constraint, and covergroup.</p>"},{"location":"Array/Operators/#array_operators_in","title":"Set membership operator <code>in</code>:","text":"TemplateSquare <pre><code>array&lt;int, 2&gt; intArray_0 = { 1, 2    };\narray&lt;int, 3&gt; intArray_1 = { 1, 2, 3 };\n\nbit bitVal_0, bitVal_1;\nif (            1 in intArray_0) bitVal_0 = 1;  ///&lt;  bitval_0: 0 -&gt; 1\nif (intArray_0[1] in intArray_1) bitVal_1 = 1;  ///&lt;  bitVal_1: 0 -&gt; 1\n</code></pre> <pre><code>int intArray_0 [2] = { 1, 2    };\nint intArray_1 [3] = { 1, 2, 3 };\n\nbit bitVal_0, bitVal_1;\nif (            1 in intArray_0) bitVal_0 = 1;  ///&lt;  bitval_0: 0 -&gt; 1\nif (intArray_0[1] in intArray_1) bitVal_1 = 1;  ///&lt;  bitVal_1: 0 -&gt; 1\n</code></pre> Note <p>Operator that do not modify contents may be used in activity, constraint, and covergroup.</p>"},{"location":"Array/Operators/#array_operators_foreach","title":"<code>foreach</code> statement:","text":"TemplateSquare <pre><code>array&lt;int, 2&gt; intArray = { 1, 2 };\n\nint intVal = 0;\nforeach (intArray[j]) {\n    intVal = intArray[j];  ///&lt;  intVal: 0 -&gt; 1 -&gt; 2\n}\n</code></pre> <pre><code>int intArray [2] = { 1, 2 };\n\nint intVal = 0;\nforeach (intArray[j]) {\n    intVal = intArray[j];  ///&lt;  intVal: 0 -&gt; 1 -&gt; 2\n}\n</code></pre> Note <p>Operator that do not modify contents may be used in activity, constraint, native exec code and covergroup.</p>"},{"location":"Operator/","title":"Expression Operators","text":""},{"location":"Operator/#expression-operators-and-data-types","title":"Expression operators and data types","text":"Operator token Operator name Operator data types Result data type <code>?:</code> Conditional operator Any plain-data type or reference type Same as operands <code>-</code> Unary arithmetic negation operator Numeric Same as operand <code>~</code> Unary bitwise negation operator Numeric Same as operand <code>!</code> Unary Boolean negation operator Boolean Boolean <code>&amp; | ^</code> Unary bitwise reduction operators Numeric 1-bit <code>+ - * / % **</code> Binary arithmetic operators Numeric 1-bit <code>&amp; | ^</code> Binary bitwise operators Numeric 1-bit <code>&gt;&gt; &lt;&lt;</code> Binary shift operators Numeric Same as left operand <code>&amp;&amp; ||</code> Binary Boolean logical operators Boolean Same as operands <code>&lt; &lt;= &gt; &gt;=</code> Binary relational operators Numeric Boolean <code>== !=</code> Binary logical equality operators Any plain-data type or reference type Boolean <code>cast</code> Data type conversion operator Numeric, Boolean, enum Casting type <code>in</code> Binary set membership operator Any plain-data type Boolean <code>[expression]</code> Index operator Array, list, map Same as element of collection <code>[expression]</code> Bit-select operators Numeric Numeric <code>[expression:expression]</code> Part-select operator Numeric Numeric"},{"location":"Operator/#941-operator-precedence-and-associativity","title":"9.4.1 Operator precedence and associativity","text":"Operator Associativity Precesence <code>()</code> <code>[]</code> Left 1 (Highest) <code>cast</code> Right 2 <code>-</code> <code>!</code> <code>~</code> <code>&amp;</code> <code>|</code> <code>^</code> (unary) 2 <code>**</code> Left 3 <code>*</code> <code>/</code> <code>%</code> Left 4 <code>+</code> <code>-</code> (binary) Left 5 <code>&lt;&lt;</code> <code>&gt;&gt;</code> Left 6 <code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>in</code> Left 7 <code>==</code> <code>!=</code> Left 8 <code>&amp;</code> (binary) Left 9 <code>^</code> (binary) Left 10 <code>|</code> (binary) Left 11 <code>&amp;&amp;</code> Left 12 <code>||</code> Left 13 <code>?:</code> (conditional operator) Right 14 (Lowest)"},{"location":"Operator/Expressions/","title":"Primary Expressions","text":""},{"location":"Operator/Expressions/#961-bit-selects-and-part-selects","title":"9.6.1 Bit-selects and part-selects","text":""},{"location":"Operator/Expressions/#primary_expressions_bit-selects","title":"Bit-selects","text":"<p>Get a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nbit bitVal = nibbleVal[1];      ///&lt;  bitVal: 0 -&gt; 1\n</code></pre></p> <p>Assign a bit of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[1] = 0;               ///&lt;  nibbleVal: 0b0011 -&gt; 0b0001\n</code></pre></p> <p>Assign a bit of variable by a non-zero integer: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[2] = 2'b10;           ///&lt;  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> <p>Operate a bit of variable by another bit: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[2] |= nibbleVal[1];   ///&lt;  nibbleVal: 0b0011 -&gt; 0b0111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\nbit bitVal = nibbleVal[10];     ///&lt;  ILLEGAL (1)\nnibbleVal[10] = 1;              ///&lt;  ILLEGAL (2)\nnibbleVal[-1] = 1;              ///&lt;  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>index must be inbound of bit-width.</li> <li>index must be inbound of bit-width.</li> <li>index shall be any integer greater than zero.</li> </ol>"},{"location":"Operator/Expressions/#primary_expressions_part-selects","title":"Part-selects","text":"<p>Get 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nbit [2] bitVal = nibbleVal[1:0];    ///&lt;  bitVal: 0b00 -&gt; 0b11\nbit [2] bitVal = nibbleVal[0:1];    ///&lt;  ILLEGAL SYNTAX (1)\n</code></pre></p> <ol> <li>LSB of range shall be smaller than MSB.</li> </ol> <p>Assign 2 bits of variable: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[1:0] = 2'b00;             ///&lt;  nibbleVal: 0b0011 -&gt; 0b0000\n</code></pre></p> <p>Operate 2 bits of variable by another 2 bits: <pre><code>bit [4] nibbleVal = 4'b0011;\nnibbleVal[3:2] |= nibbleVal[1:0];   ///&lt;  nibbleVal: 0b0011 -&gt; 0b1111\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>bit [4] nibbleVal = 4'b0011;\nbit [2] bitVal = nibbleVal[4:3];    ///&lt;  ILLEGAL (1)\nnibbleVal[4:3] = 2'b01;             ///&lt;  ILLEGAL (2)\nnibbleVal[0:-1] = 2'b01;            ///&lt;  ILLEGAL SYNTAX (3)\n</code></pre> <ol> <li>MSB/LSB of range must be inbound of bit-width.</li> <li>MSB/LSB of range must be inbound of bit-width.</li> <li>MSB/LSB of range shall be any integer greater than zero.</li> </ol>"},{"location":"Operator/Expressions/#primary_expressions_indexing","title":"9.6.2 Selecting an element from a collection (indexing)","text":"<p>Get an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[0]  ;  ///&lt;  nibbleArrayVal: 0 -&gt; 0b1100\nbit [4] nibbleListVal  = nibbleList[1]   ;  ///&lt;  nibbleListVal : 0 -&gt; 0b0110\nbit [4] nibbleMapVal   = nibbleMap[\"ONE\"];  ///&lt;  nibbleMapVal  : 0 -&gt; 0b1100\n</code></pre></p> <p>Assign an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nnibbleArray[0]   = 4'b0011;  ///&lt;  nibbleArray[0]  : 0b1100 -&gt; 0b0011\nnibbleList[0]    = 4'b0011;  ///&lt;  nibbleList[0]   : 0b1100 -&gt; 0b0011\nnibbleMap[\"ONE\"] = 4'b0001;  ///&lt;  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b0001\nnibbleMap[\"TWO\"] = 4'b0110;  ///&lt;  nibbleMap[\"TWO\"]: no_exist -&gt; 0b0110 (1)\n</code></pre></p> <ol> <li><code>map</code> will add the element if no existed.</li> </ol> <p>Operate an element of collection (e.g., array, list, map): <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100,        4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100,        4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100, \"TWO\": 4'b0110};\n\nnibbleArray[0]   |= nibbleArray[1]  ;  ///&lt;  nibbleArray[0]  : 0b1100 -&gt; 0b1110\nnibbleList[0]    |= nibbleList[1]   ;  ///&lt;  nibbleList[0]   : 0b1100 -&gt; 0b1110\nnibbleMap[\"ONE\"] |= nibbleMap[\"TWO\"];  ///&lt;  nibbleMap[\"ONE\"]: 0b1100 -&gt; 0b1110\n</code></pre></p> Illegal: Access out-of-bounds <pre><code>array&lt;bit [4], 2&gt;      nibbleArray = {       4'b1100, 4'b0110};\nlist &lt;bit [4]&gt;         nibbleList  = {       4'b1100, 4'b0110};\nmap  &lt;string, bit [4]&gt; nibbleMap   = {\"ONE\": 4'b1100         };\n\nbit [4] nibbleArrayVal = nibbleArray[2]  ;  ///&lt;  ILLEGAL (1)\nbit [4] nibbleListVal  = nibbleList[2]   ;  ///&lt;  ILLEGAL (2)\nbit [4] nibbleMapVal   = nibbleMap[\"TWO\"];  ///&lt;  ILLEGAL (3)\n</code></pre> <ol> <li>index must be inbound of size.</li> <li>index must be inbound of size.</li> <li>The element must be exist in the <code>map</code>.</li> </ol>"},{"location":"Operator/Expressions/#usage","title":"Usage","text":"Access bit of an array <pre><code>array&lt;bit [4], 2&gt; nibbleArray = {4'b1100, 4'b0110};\n\nbit bitOnArray_0_2 = nibbleArray[0][2]; ///&lt;  bitOnArray_0_2: 0 -&gt; 1\nnibbleArray[1][0] = 1;                  ///&lt;  nibbleArray[1]: 0b0110 -&gt; 0b0111\n</code></pre>"}]}